.. _tut-modules:

*******
Модули
*******

Если вы вышли из интерпретатора питона и снова вошли, то определения которые
вы сделали (функции и переменные) потеряны. Поэтому, если вы хотите написать
более длинную программу, вам лучше использовать текстовый редактор чтобы
приготовить ввод для интерпретатора и запускать его с этим файлом в качестве
входных данных. Это действие называется созданием *сценария*. С тем как
ваша программа становится длиннее, мы можете захотеть разделить её на несколько
файлов для более простой поддержки. Вы также можете захотеть использовать
удобную функцию которую вы написали для нескольких программ без того чтобы
каждый раз копировать её определение в каждую программу.

Для этого в Python существует возможность размещать определения в файл и
использовать их в сценарии или в интерактивном режиме интерпретатора. Такой
файл называется *модуль*; определения из модуля могут быть
*импортированы* в другие модули или в *главный* модуль (коллекция
переменных к которой вы имеете доступ из выполняемого сценария на верхнем
уровне и в режиме калькулятора).

Модуль это файл, содержащий определения на Python и операторы. Имя этого файла
это имя модуля с добавлением суффикса :file:`.py`. Внутри модуля, это имя
модуля доступно (в форме строки) как глобальная переменная ``__name__``.
Например, используйте ваш любимый текстовый редактор чтобы создать файл под
названием :file:`fibo.py` в текущей директории, со следующим содержимым::

   # Модуль чисел Фибоначчи

   def fib(n):   # вывести ряд Фибоначчи вплоть до n
       a, b = 0, 1
       while b < n:
           print(b, end=' ')
           a, b = b, a+b
       print()

   def fib2(n): # вернуть ряд фибоначчи вплоть до n
       result = []
       a, b = 0, 1
       while b < n:
           result.append(b)
           a, b = b, a+b
       return result

Теперь войдите в интерпретатор питона и импортируйте этот модуль с помощью
следующей команды::

   >>> import fibo

Это не добавит имена функций объявленных в ``fibo`` напрямую из текущую
символьную таблицу; это только добавит имя модуля ``fibo`` сюда. Используя имя
этого модуля вы можете получить доступ к функциям::

   >>> fibo.fib(1000)
   1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
   >>> fibo.fib2(100)
   [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
   >>> fibo.__name__
   'fibo'

Если вы планирует часто использовать какую-либо функцию, вы можете присвоить её
переменной::

   >>> fib = fibo.fib
   >>> fib(500)
   1 1 2 3 5 8 13 21 34 55 89 144 233 377


.. _tut-moremodules:

Подробнее о модулях
===================

Модуль может содержать выполняемые операторы так же, как и объявления функций.
Эти операторы предназначены для инициализации модуля. Они выполняются только в
*первый* раз, когда имя модуля встречается после ключевого слова import. [#]_
(Они также выполняются если файл запускается в качестве сценария).

В каждом модуле есть своя, приватная символьная таблица, которая используется
как глобальная символьная таблица всеми функциями объявленными в данном модуле.
Хотя, автор модуля может использовать глобальные переменные в модуле не
беспокоясь о случайных конфликтах с пользовательскими глобальными переменными.
С другой стороны, если вы знаете, что делаете, вы можете получить доступ к
глобальным переменным модуля используя ту же нотацию, которая используется для
доступа к его функциям, ``modname.itemname``.

Модули могут импортировать другие модули. Является общепринятым, но совсем не
обязательно размещать все :keyword:`import` в начале модуля (ну или сценария).
Импортированные имена модулей попадают в глобальную таблицу импортирующего
модуля.

Вот вариант :keyword:`import` который импортирует имена из модуля напрямую в
символьную таблицу импортирующего модуля. Например::

   >>> from fibo import fib, fib2
   >>> fib(500)
   1 1 2 3 5 8 13 21 34 55 89 144 233 377

Это не вводит имя модуля из которого взяты все импорты, в локальную символьную
таблицу (так что в этом примере, ``fibo`` не определён).

Есть вариант импортировать все имена которые определяет модуль::

   >>> from fibo import *
   >>> fib(500)
   1 1 2 3 5 8 13 21 34 55 89 144 233 377

Так импортиуются все имена, кроме тех которые начинаются с символа
подчёркивания (``_``).  В большинстве случаев программисты на Питоне не
используют это возможность, т.к. это вводит неопределённое количество имён в
интерпретатор, и может спрятать некоторые вещи которые вы уже определили.

Обратите внимание, что в повседневной практике импортирование ``*`` из модуля
или пакета не одобряется, т.к. это часто приводит к трудно читаемому коду.
Однако,это допускается для сокращения вводимого в интерактивных сессиях кода.

.. note::

   Эффективности ради, каждый модуль импортируется только один раз на каждую
   сессию интерпретатора.  Поэтому, если вы изменили ваши модули, вам нужно
   перезапустить интерпретатор -- или, если это  это только один модуль,
   который вы хотите протестировать в интерактивном режиме, используйте
   :func:`imp.reload`, например ``import imp; imp.reload(modulename)``.


.. _tut-modulesasscripts:

Выполнение модулей как скриптов
-------------------------------

Когда вы запускаете Python с модулем ::

   python fibo.py <arguments>

код в модуле будет выполнен, точно так же, если бы вы импортировали его, но с
``__name__`` выставленным в ``"__main__"``.  Это означает, что that добавляя
этот код в конец вашего модуля::

   if __name__ == "__main__":
       import sys
       fib(int(sys.argv[1]))

вы можете использовать этот файл как скрипт, точно так же можете его
импортировать, потому что код который обрабатывает командную строку запускается
только если модуль выполняется как "main" (главный) файл::

   $ python fibo.py 50
   1 1 2 3 5 8 13 21 34

Если модуль импортирован, код не запускается::

   >>> import fibo
   >>>

Это часто используется или для удобного интерфейса пользователя для модуля, или
для тестирования (запуска модуля как скрипта выполняет тестовый набор).


.. _tut-searchpath:

Путь поиска модулей
-------------------

.. index:: triple: module; search; path

Когда модуль под названием :mod:`spam` импортируется, интерпретатор в начале
ищет встроенный модуль с таким именем. Если не находит, он ищет файл под
названием :file:`spam.py` в списке директорий который содержится в переменной
:data:`sys.path`.  :data:`sys.path` инициализируется из этих мест:

* Директория содержащая входной скрипт (или текущая директория если файл не был
  указан).
* :envvar:`PYTHONPATH` (список директорий, точно такой же как переменная
  окружения оболочки командной строки :envvar:`PATH`).
* Значение по умолчанию заданное в процессе установки.

.. note::
   На файловых системах поддерживающих симолические ссылки, директория
   содержащая входной скрипт вычисляется из конечного пути символической
   ссылки. Другими словами директория содержащая символическую ссылку **не**
   добавляется к пути поиска модулей.

После инициализации, программы на Питоне могут модифицировать :data:`sys.path`.
Директория содержащая скрипт который будет запущен помещается в начала списка
поиска, перед путём к стандартным библиотекам. Это означает, что скрипты в этой
директории будут загружены вместо модулей с теми же именами в директории
библиотеки. Это является ошибкой, если конечно не подразумевается замена.
Смотрите раздел :ref:`tut-standardmodules` для получения дополнительной
информации.

.. %
    Do we need stuff on zip files etc. ? DUBOIS

"Скомпилированные" файлы Python
-------------------------------

Для ускорения загрузки модулей, Python кеширует скомпилированные версии каждого
модуля в директории ``__pycache__`` под именем :file:`module.{version}.pyc`,
где version обозначает формат скомпилированного файла; обычно это номер версии
Python.  Например, в CPython выпуск 3.3 скомпилированная версия spam.py была бы
закеширована как ``__pycache__/spam.cpython-33.pyc``.  Это соглашение о
именовании позволяет скомпилированным разными версиями и выпусками Python -
сосуществовать.

Python сверяет даты модификации исходного и скомпилированного файлов чтобы
определить нужна ли перекомпиляция.  Это полностью автоматический процесс.  К
тому же, скомпилированные модули платформо-независимы, так что та же самая
библиотека может быть использована на системах с разными архитектурами.

Python не проверяет кеш в двух случаях. Во-первых, он всегда перекомпилирует и
не сохраняет результат  модуля загруженного напрямую из командной строки.
Во-вторых, он не проверяет кеш если не существует исходного модуля.  Чтобы
поддерживать распространение без исходных файлов (только в двоичном виде),
скомпилированный модуль должен находиться в исходной директории, и там может не
быть исходного модуля.

Несколько советов для экспертов:

* Вы можете использовать ключи :option:`-O` или :option:`-OO` в команде Питона
  чтобы уменьшить размер скомпилированного модуля.  Ключ ``-O`` удаляет
  выражения assert, а ключ ``-OO`` удаляет assert и строки __doc__.
  Т.к. некоторые программы могут рассчитывать на них, вам следует использовать
  эту возможность только если вы знаете, что делаете.  "Оптимизированные" модули
  имеют расширение .pyo а не .pyc и обычно меньше по размеру.  В будущих
  выпусках эффект от оптимизации может измениться.

* Скорость выполнения программы для файлов ``.pyc`` и ``.pyo`` точно такая же
  как если бы она была прочитана из ``.py`` файла; единственная вещь которая
  выполняется быстрее для файлов ``.pyc`` и ``.pyo``, это скорость из загрузки.

* Модуль :mod:`compileall` может создавать .pyc файлы (или .pyo, когда
  используется опция :option:`-O`), для всех файлов в директории.

* Подробная информации об этом процессе, включая диаграмму решений содержится в
  PEP 3147.


.. _tut-standardmodules:

Стандартные модули
==================

.. index:: module: sys

Python поставляется с библиотекой стандартных модулей, описанной в отдельном
документе, Справка по Библиотеке Python (далее "Справка по библиотеке").
Некоторые модули встроены в интерпретатор; они предоставляют доступ к операциям
которые не являются частью ядра языка, но тем не менее, являются встроенными,
либо для эффективности либо предоставляют доступ к примитивам операционной
системы, таким как системные вызовы.  Набор таких модулей, это настраиваемая
возможность которая в т.ч. зависит от используемой платформы.  Например, модуль
:mod:`winreg` доступен только на системах Windows. Один особый модуль достоин
особого внимания: :mod:`sys`, он встроен в каждый интерпретатор Питона.
Переменные ``sys.ps1`` и ``sys.ps2`` определяют строки используемые как
первичное и вторичное приглашения::

   >>> import sys
   >>> sys.ps1
   '>>> '
   >>> sys.ps2
   '... '
   >>> sys.ps1 = 'C> '
   C> print('Фу!')
   Фу!
   C>


Эти две переменные определены только если интерпретатор запущен в интерактивном
режиме.

Переменная ``sys.path`` это список строк которые указывают интерпретатору пути
для поиска модулей. Она инициализируется по умолчанию в значение равное
переменной окружения :envvar:`PYTHONPATH`, или встроенному значению, если
:envvar:`PYTHONPATH` не настроен.  Вы можете модифицировать её стандартным
способом::

   >>> import sys
   >>> sys.path.append('/ufs/guido/lib/python')


.. _tut-dir:

Функция :func:`dir`
===================

Встроенная функция :func:`dir` используется чтобы узнать какие имена определяет
модуль.  Она возвращает отсортированный список строк::

   >>> import fibo, sys
   >>> dir(fibo)
   ['__name__', 'fib', 'fib2']
   >>> dir(sys)  # doctest: +NORMALIZE_WHITESPACE
   ['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
    '__package__', '__stderr__', '__stdin__', '__stdout__',
    '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
    '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
    'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
    'call_tracing', 'callstats', 'copyright', 'displayhook',
    'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
    'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
    'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
    'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
    'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',
    'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
    'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
    'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
    'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
    'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
    'thread_info', 'version', 'version_info', 'warnoptions']

Без параметров, :func:`dir` выводит список имён определённых в данный момент::

   >>> a = [1, 2, 3, 4, 5]
   >>> import fibo
   >>> fib = fibo.fib
   >>> dir()
   ['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']

Обратите внимание, что список содержит все типы имён: переменные, модули,
функции, и т.д.

.. index:: module: builtins

:func:`dir` не выводит имена встроенных функций и переменных.  Если вы хотите
посмотреть именно их, то они определены в стандартом модуле :mod:`builtins`::

   >>> import builtins
   >>> dir(builtins)  # doctest: +NORMALIZE_WHITESPACE
   ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
    'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
    'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
    'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
    'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
    'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
    'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
    'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
    'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
    'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
    'NotImplementedError', 'OSError', 'OverflowError',
    'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
    'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
    'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
    'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
    'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
    'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
    'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
    '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
    'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',
    'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',
    'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',
    'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
    'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
    'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',
    'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',
    'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
    'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
    'zip']

.. _tut-packages:

Пакеты
======

Пакеты, это способ структурирования пространства имён модулей Python используя
"имена модулей с точкой".  Например, имя модуля :mod:`A.B` обозначает подмодуль
с именем ``B`` в пакете с именем ``A``.  Точно так же как использование модулей
спасает авторов разных модулей от необходимости беспокоиться об именах
глобальных переменных друг друга, использование точечных имён модулей спасает
авторов многомодульных пакетов, таких как NumPy или PIL от необходимости
беспокоиться об именах модулей друг друга.

Предположим, что вы хотите разработать коллекцию модулей ("пакет") для
единообразной поддержки звуковых файлов и данных.  Существует множество разных
форматов звуковых файлов (обычно различающихся расширением, например:
:file:`.wav`, :file:`.aiff`, :file:`.au`), так что вам может потребоваться
создать и поддерживать растущую коллекцию модулей для преобразования разных
форматов файлов.

Так же существует множество различных операций которые вы возможно захотите
произвести над звуковыми данными (такие как миксинг, добавление эхо, применение
эквалайзера, создание искусственного стерео эффекта), так что в дополнение ко
всему, вы будете писать бесконечную череду модулей производящих эти операции.
Вот возможная структура вашего пакета (выраженная в виде иерархической файловой
системы):

.. code-block:: text

   sound/                          Пакет верхнего уровня
         __init__.py               Инициализация звукового пакета
         formats/                  Подпакет для преобразования форматов файлов
                 wavread.py
                 wavwrite.py
                 aiffread.py
                 aiffwrite.py
                 auread.py
                 auwrite.py
                 ...
         effects/                  Подпакет для звуковых эффектов
                 __init__.py
                 echo.py
                 surround.py
                 reverse.py
                 ...
         filters/                  Подпакет для фильтров
                 __init__.py
                 equalizer.py
                 vocoder.py
                 karaoke.py
                 ...

Когда импортируется этот пакет, Python ищет в директориях перечисленных в
``sys.path`` пытаясь найти поддиректорию пакета.

Файлы :file:`__init__.py` необходимы для того чтобы Python принимал директории
как содержащие пакеты; это сделано для того чтобы директории с
распространёнными именами, такими как ``string``, случайно не спрятали нужные
модули которые встречаются далее в пути поиска. В простейшем случае,
:file:`__init__.py` может быть просто пустым файлом, но он так же может
выполнять инициализацию кода для пакета или устанавливать переменную
``__all__``, описанную далее.

Пользователи пакета могут импортировать индивидуальные модули из этого пакета,
например::

   import sound.effects.echo

Это загружает подмодуль :mod:`sound.effects.echo`.  На него необходимо
ссылаться используя полное имя. ::

   sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)

Альтернативный способ импортирования этого подмодуля::

   from sound.effects import echo

Это так же загружает подмодуль :mod:`echo`, и делает его доступным без его
пакетного префикса, так что он может быть использован следующим образом::

   echo.echofilter(input, output, delay=0.7, atten=4)

Ещё один способ импортирования нужной функции или переменной напрямую::

   from sound.effects.echo import echofilter

Снова, это загружает подмодуль :mod:`echo`, но делает его функцию
:func:`echofilter` доступной напрямую::

   echofilter(input, output, delay=0.7, atten=4)

Обратите внимание, что когда используется ``from package import item``, этот
item может быть как подмодулем (или подпакетом) пакета, или неким другим именем
определённым в этом пакете, как то функция, класс или переменная.  Оператор
``import`` сначала проверяет определён ли item в пакете или нет; если нет, он
предполагает, что это модуль и пытается его загрузить.  Если его не удаётся
найти, выбрасывается исключение :exc:`ImportError`.

И наоборот, когда используется синтаксис ``import item.subitem.subsubitem``,
каждый элемент, кроме последнего должен быть в пакете; последний элемент может
быть модулем или пакетом, но не может быть классом, функцией или переменной
определённой в предыдущем элементе.


.. _tut-pkg-import-star:

Импортирование \* из пакета
---------------------------

.. index:: single: __all__

А что происходит когда пользователь пишет ``from sound.effects import *``?  В
идеале, ему бы надеяться на то, что это каким-то образом найдёт в файловой
системе какие подмодули находятся в пакете и импортирует их все.  Это может
занять некоторое время и импортирование подмодулей может иметь нежелательные
побочные эффекты которым следует происходить только когда подмодуль
импортирован явно.

Единственным решением для автора пакета -- предоставить явно заданный перечень
этого пакета.  Оператор :keyword:`import` использует следующее соглашение: если
код пакета :file:`__init__.py` определяет список названный ``__all__``, это и
становится списком имён модулей которые следует импортировать когда встречается
``from package import *``.  Поддержка этого списка в актуальном состоянии
ложиться на плечи автора когда выпускается новая версия пакета.  Авторы пакетов
могут также решить не поддерживать это, если они не видят смысла в
импортировании \* из их пакета.  Например, файл
:file:`sound/effects/__init__.py` может содержать следующий код::

   __all__ = ["echo", "surround", "reverse"]

Это бы означало, что ``from sound.effects import *`` импортирует эти три
подмодуля из пакета :mod:`sound`.

Если ``__all__`` не определён, выражение ``from sound.effects import *`` *не*
импортирует все подмодули из пакета :mod:`sound.effects` в текущее пространство
имён; это только удостоверится в том, что пакет :mod:`sound.effects`
импортирован (возможно запустит инициализирующий код в :file:`__init__.py`) и
затем импортирует какие бы то ни было имена определённые в пакете.  Это
включает любые имена определённые (и подмодули явно загруженные) файлом
:file:`__init__.py`.  Это так же включает любые подмодули пакета который явно
загружен предыдущими операторами :keyword:`import`.  Рассмотрим этот код::

   import sound.effects.echo
   import sound.effects.surround
   from sound.effects import *

В этом примере, модули :mod:`echo` и :mod:`surround` импортированы в текущее
пространство имён потому что они определены в пакете :mod:`sound.effects` когда
выражение ``from...import`` выполнилось.  (Это так же работает когда
``__all__`` определён).

Хотя определённые модули разработаны чтобы экспортировать только те имена
которые следуют определённым шаблонам, когда вы видите ``import *``, это
считается плохой практикой для production code.

Запомните, нет ничего плохого в том чтобы использовать ``from Package import
specific_submodule``!  На самом деле, это рекомендованная нотация до тех пор
пока не потребуется импортировать модуль который использует подмодули с теми же
именами из других пакетов.


Внутрипакетные ссылки
---------------------

Когда пакеты структурированы в подпакеты (как в случае с пакетом :mod:`sound` в
нашем примере), вы можете использовать абсолютные импорты чтобы ссылаться на
подмодули родственных пакетов.  Например, если модулю
:mod:`sound.filters.vocoder` нужно использовать модуль :mod:`echo` в пакете
:mod:`sound.effects`, он может использовать ``from sound.effects import echo``.

Вы так же можете писать относительные импорты при помощи формы ``from module
import name`` оператора import.  Эти импорты используют точки в начале чтобы
указывать на текущий и родительский пакеты вовлечённые в относительный импорт.
Из модуля :mod:`surround`, например, вы можете использовать::

   from . import echo
   from .. import formats
   from ..filters import equalizer

Обратите внимание на то, что относительные импорты основаны на имени текущего
модуля.  Т.к. имя главного модуля всегда ``"__main__"``, модули предназначенные
для использования в главном модуле приложения на Питоне должны всегда
использовать абсолютные импорты.


Пакеты в нескольких директориях
-------------------------------

Пакеты поддерживающие один специальный атрибут, :attr:`__path__`.  Он
инициализируется списком  содержащим имя директории хранящей
:file:`__init__.py` пакета до того как код в этом файле будет выполнен.  Эта
переменная может быть модифицирована; сделав это вы повлияете на последующие
поиски модулей и подпакетов содержащихся в этом пакете.

До тех пор, Пока эта возможность нужна не так часто, она может быть
использована для расширения набора модулей найденных в пакете.


.. rubric:: Footnotes

.. [#] На самом деле определения функций это тоже 'выражения' которые 
	'выполняются'; выполнение определения функции уровня модуля вводит
	имя этой функции в глобальную таблицу имён этого модуля.

