.. _tut-errors:

********************************
Ошибки и исключительные ситуации
********************************

До настоящего момента, мы только упоминали сообщения об ошибках, но если вы
испытывали примеры, вы возможно видели некоторые.  Вот как минимум два
различающихся вида ошибок: *синтаксические ошибки* и *исключения*.


.. _tut-syntaxerrors:

Синтаксические ошибки
=====================

Синтаксические ошибки, так же известные как ошибки разбора, возможно, наиболее
распространённый вид жалоб, который вы будете встречать изучая Python::

   >>> while True print('Hello world')
     File "<stdin>", line 1, in ?
       while True print('Hello world')
                      ^
   SyntaxError: invalid syntax

Парсер повторяет провинившуюся строку и показывает маленькую 'стрелку'
указывающую на самую раннюю точку в строке где была обнаружена ошибка.  Ошибка
возникла (или хотя бы обнаружена), в токене *перед* стрелкой: в этом примере,
ошибка обнаружена в функции :func:`print`, т.к. двоеточие (``:``) пропущено
перед ней.  Выводятся имя файла и номер строки, так чтобы вы знали где смотреть
в случае если входные данные получены из скрипта.


.. _tut-exceptions:

Исключительные ситуации
=======================

Даже если оператор или выражение синтаксически корректны, ошибка возможна при
попытке их выполнения. Ошибки обнаруженные на этапе выполнения нзываются
*exceptions* (исключительные ситуации), и они не всегда фатальны: Вы скоро
научитесь как обрабатывать их в программах на Питоне.  Большинство исключений
не обрабатываются программами, однако, результат ошибки показан здесь::

   >>> 10 * (1/0)
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   ZeroDivisionError: division by zero
   >>> 4 + spam*3
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   NameError: name 'spam' is not defined
   >>> '2' + 2
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   TypeError: Can't convert 'int' object to str implicitly

Последняя строка в сообщении об ошибке указывает что случилось. Исключения
бывают разных типов, и тип выводится как часть сообщения: такими типами в
примере являются :exc:`ZeroDivisionError`, :exc:`NameError` и :exc:`TypeError`.

Эта строка выводится как тип исключение имя этого встроенного исключения то,
что появляется.  Это истинно для всех встроенных исключений, но не обязательно
истинно для исключений определённых пользователем (хотя, это удобное
соглашение). Стандартные исключения являются встроенными индентификаторами (а
не зарезервированными словами).

Оставшаяся часть строки предоставляет подробности в зависимости от типа
исключения и того, что послужило его причиной.

Предшествующая часть ошибочного сообщения показывает контекст, где произошло
исключение в этой форме отслеживания стека. Вообще это содержит стековый
отслеживающий листинг исходного текста; Однако, это не будет отображать линии
со стандартного ввода.

В :ref:`bltin-exceptions` перечислены встроенные исключения и их назначение.


.. _tut-handling:

Обрабатывание исключений
========================

Существует возможность написания программ, которые умеют обрабатывать выбранные
исключения. Взгляните на пример, расположенный ниже, в котором пользователю
предложен ввод целого числа до тех пор, пока введённое число действительно
целое, но разрешает пользователю прервать выполнение программы (используя
комбинацию клавиш :kbd:`Ctrl-C` или аналогичную ей, которую поддерживает конкретная
операционная система); стоит отметить, что прерывание работы программы,
инициируемое пользователем, вызывается срабатыванием исключения прерывания
клавиатуры :exc:`KeyboardInterrupt`. ::

   >>> while True:
   ...     try:
   ...         x = int(input("Пожалуйста введите число: "))
   ...         break
   ...     except ValueError:
   ...         print("Ой!  Это неправильное число.  Попробуйте снова...")
   ...

Ключевое слово :keyword:`try` работает следующим образом.

* Сначала, выполняются *выражение try* (операторы между :keyword:`try` и
  :keyword:`except`).

* Если не происходит исключения, *выражение except* пропускается и выоплнение
  выражения :keyword:`try` заканчивается.

* Если исключение происходит во время выполнения выражения try, остаток
  выражения пропускается.  Затем, если один из типов исключений указанных после
  ключевого слова :keyword:`except`, совпает, это except выражение выполняется,
  и затем выполнение продолжается после выражения :keyword:`try`.

* Если происходит исключение не укзанное в except выражении, оно передаётся во
  ввшешний блок :keyword:`try`; если не найдено обработчика, это
  *необработанное исключение*, выполнение останавливается и выводится сообщение
  показанное выше.

Оператор :keyword:`try` может содержать более одного блока except, чтобы
обозначить обработчики для разных исключений.  Как минимум один обработчик
будет выполнен.  Обработчики обрабатывают только те исключения которые
встречаются в соотвестующем блоке try, а не в других обработчиках того же блока
:keyword:`try`.  В блоке except может быть перечислено несколько исключений в
виде кортежа в скобках, например::

   ... except (RuntimeError, TypeError, NameError):
   ...     pass

Последний блок except может вовсе не содержать исключений, выступая в роли
обработчика для всех исключений.  Пользуйтесь этой возможностью с большой
осторожностью, ибо таким образом можно замаскировать реальную ошибку в
программе!  Этот способ можно так же исползовать для вывода сообщения об ошибке
и повторного выброса исключения (позволяя вызывающему дополнительно обработать
исключение)::

   import sys

   try:
       f = open('myfile.txt')
       s = f.readline()
       i = int(s.strip())
   except OSError as err:
       print("OS error: {0}".format(err))
   except ValueError:
       print("Could not convert data to an integer.")
   except:
       print("Unexpected error:", sys.exc_info()[0])
       raise

Операторы :keyword:`try` ... :keyword:`except` имеют необязательный блок
*else*, который, если он присутствует, должен следовать после всех блоков
except.  Это бывает полезно для кода который должен быть выполнен в случае если
в блоке try не произойдёт исключения.  Например::

   for arg in sys.argv[1:]:
       try:
           f = open(arg, 'r')
       except IOError:
           print('cannot open', arg)
       else:
           print(arg, 'has', len(f.readlines()), 'lines')
           f.close()

Блок :keyword:`else` лучше применять добавив дополнительный код в блок
:keyword:`try`, потому что это исключает случайное попадание исключения которое
не было вызвано кодом защищаемым блоком :keyword:`try` ... :keyword:`except`.

Когда случается исключительная ситуация, исключение может содержать связанное
значение, так же известное как *параметр исключения*. Наличие и тип параметра
зависит от типа исключения.

В блоке except можно указать переменную после имени исключения.  Эта переменная
привязана к экземпляру исключения вместе с аргументом который хранится
``instance.args``.  Для удобства, экземпляр исключения объявляет
:meth:`__str__` так что параметры могут быть распечатаны без прямого обращения
к ``.args``.  Ещё можно инициализировать исключение перед его выбросом и
добавить ему желаемые атрибуты. ::

   >>> try:
   ...    raise Exception('spam', 'eggs')
   ... except Exception as inst:
   ...    print(type(inst))    # экземпляр исключения
   ...    print(inst.args)     # параметны хранящиеся в .args
   ...    print(inst)          # __str__ позволяет распечатывать параметры
   ...                         # напрямую, но может быть переназначен в 
   ...                         # наследуемых от исключения классах
   ...    x, y = inst.args     # распаковать args
   ...    print('x =', x)
   ...    print('y =', y)
   ...
   <class 'Exception'>
   ('spam', 'eggs')
   ('spam', 'eggs')
   x = spam
   y = eggs

Если исключение имеет параметры, они выводятся в последней части "подробности"
('detail') сообщения об необработанных исключениях.

Обработчики исключений не просто обрабатывают исключения если они появляются
сразу после блока try, но также если встречаются внутри функции которая вызвана
(даже не напрямую) в блоке try. Например::

   >>> def this_fails():
   ...     x = 1/0
   ...
   >>> try:
   ...     this_fails()
   ... except ZeroDivisionError as err:
   ...     print('Handling run-time error:', err)
   ...
   Handling run-time error: int division or modulo by zero


.. _tut-raising:

Вызов исключений
================

Ключевое слово :keyword:`raise` позволяет программисту вызвать указанное
исключение. Например::

   >>> raise NameError('HiThere')
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   NameError: HiThere

Единственный аргумент :keyword:`raise` указывает этому исключению быть
выброшенным. Это может быть экземпляр исключения или класс исключения (класс
который наследован от :class:`Exception`).

Если вам нужно определить где было возникло исключение, но вы не собираетесь
его обрабатывать, простейшая форма ключевого слова :keyword:`raise` позволяет
вам повторно выбросить исключение::

   >>> try:
   ...     raise NameError('HiThere')
   ... except NameError:
   ...     print('An exception flew by!')
   ...     raise
   ...
   An exception flew by!
   Traceback (most recent call last):
     File "<stdin>", line 2, in ?
   NameError: HiThere


.. _tut-userexceptions:

Исключения определённые пользователем
=====================================

Программы могут использовать свои собственные исключения путём создания класса
исключения (см.  :ref:`tut-classes` чтобы узнать больше о классах в Python).
Исключения обычно наследуют от класса :exc:`Exception`, прямо или косвенно.
Например::

   >>> class MyError(Exception):
   ...     def __init__(self, value):
   ...         self.value = value
   ...     def __str__(self):
   ...         return repr(self.value)
   ...
   >>> try:
   ...     raise MyError(2*2)
   ... except MyError as e:
   ...     print('My exception occurred, value:', e.value)
   ...
   My exception occurred, value: 4
   >>> raise MyError('oops!')
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   __main__.MyError: 'oops!'

В этом примере, метод по умолчанию :meth:`__init__` класса :class:`Exception`
был переназначен.  Новое поведение просто создаёт атрибут *value*.  Это
изменяет стандартное поведение создающее атрибут *args*.

Классы исключений могут быть определены для выполнения всех тех задач, которые
может выполнять обычный класс, но обычно остаются простыми, часто предлагая
только несколько атрибутов которые позволяют обработчикам исключения извлечь
информацию об ошибке.  Когда создаётся модуль который выбрасывает несколько
отдельных ошибок, общей практикой является создание базового класса для
исключений объявленных в этом модуле и наследовать этот класс чтобы создать
специфические классы исключений для разных ошибок::

   class Error(Exception):
       """Базовый класс для исключения в этом модуле."""
       pass

   class InputError(Error):
       """Исключение выбрасываемое при ошибках во вводе.

       Attributes:
           expression -- входное выражение в котором произошла ошибка
           message -- описание ошибки
       """

       def __init__(self, expression, message):
           self.expression = expression
           self.message = message

   class TransitionError(Error):
       """Выбрасывается когда операция пытается перейти в состояние передачи,
       которое не разрешено.

       Attributes:
           previous -- состояние в начале передачи
           next -- попытка нового состояния
           message -- объяснение почему специфическая передача не разрешена
       """

       def __init__(self, previous, next, message):
           self.previous = previous
           self.next = next
           self.message = message

Большинство исключений определяются с именами заканчивающимися на "Error,"
аналогично тому, как именуются стандартные исключения.

Многие стандартные модули определяют их собственные исключения чтобы
докладывать об ошибках которые могут происходить в функциях которые они
определяют.  Более подробная информация о классах содержится в главе
:ref:`tut-classes`.


.. _tut-cleanup:

Определение функций очистки
===========================

У оператора :keyword:`try` есть другой необязательный блок который предназначен
для определения действий очистки и должен выполняться при любых условиях.
Например::

   >>> try:
   ...     raise KeyboardInterrupt
   ... finally:
   ...     print('Goodbye, world!')
   ...
   Goodbye, world!
   Traceback (most recent call last):
     File "<stdin>", line 2, in ?
   KeyboardInterrupt

*Блок finally* всегда выполняется перед тем как покинуть оператор
:keyword:`try`, независимо от того произошло исключение или нет. Когда в блоке
:keyword:`try` происходит исключение и оно не обрабатывается блоком
:keyword:`except` (или оно происходит в блоках :keyword:`except` или
:keyword:`else`), оно выбрасывается снова после того как блок
:keyword:`finally` будет выполнен.  Блок :keyword:`finally` так же выполняется
"на выходе" когда происходит выход из всех других блоков оператора
:keyword:`try` через операторы :keyword:`break`, :keyword:`continue` или
:keyword:`return`.  Более сложный пример::

   >>> def divide(x, y):
   ...     try:
   ...         result = x / y
   ...     except ZeroDivisionError:
   ...         print("division by zero!")
   ...     else:
   ...         print("result is", result)
   ...     finally:
   ...         print("executing finally clause")
   ...
   >>> divide(2, 1)
   result is 2.0
   executing finally clause
   >>> divide(2, 0)
   division by zero!
   executing finally clause
   >>> divide("2", "1")
   executing finally clause
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
     File "<stdin>", line 3, in divide
   TypeError: unsupported operand type(s) for /: 'str' and 'str'

Как можно заметить, блок :keyword:`finally` при любом событии.
:exc:`TypeError` выбрасывается делением двух строк не обработанным блоком
:keyword:`except` и поэтому выбрасывается снова после того как выполняется блок
:keyword:`finally`.

В реальных приложениях, блок :keyword:`finally` применяется для освобождения
внешних ресурсов (таких как файлы или сетевые подключения), независимо от того
было ли использование ресурса успешным или нет.


.. _tut-cleanup-with:

Предопределённые действия очистки
=================================

Некоторые объекты определяют стандартные действия по очистке, которые
происходят когда объект больше не нужен, независимо от того была ли операция
использующая объект успешной или нет. Взгляните на пример ниже, в котором
осуществляется попытка открыть файл и распечатать его содержимое на экране. ::

   for line in open("myfile.txt"):
       print(line, end="")

Проблема в этом коде в том, что после его выполнения, файл остаётся открытым
неопределённое количество времени.  Это не является проблемой для простых
скриптов, но может быть проблемой для больших приложений. Оператор
:keyword:`with` позволяет использовать такие объекты как файлы, таким способом,
чтобы всегда быть уверенным в том что всё будет очищено вовремя и корректно. ::

   with open("myfile.txt") as f:
       for line in f:
           print(line, end="")

После того как этот код будет выполнен, файл *f* всегда будет закрыт, даже если
возникнет проблема в процессе обработки  строк. Объекты, такие как файлы,
предоставляют предопределённые действия по очистке о которых рассказано в их
документации.


