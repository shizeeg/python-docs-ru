.. _tut-structures:

*****************
Структруры данных
*****************

Эта глава описывает вещи о которых вы уже знаете, более подробно, а так же
рассказывает о некоторых новых вещах.

.. _tut-morelists:

Подробнее о списках
===================

В типе данных список есть ещё методы.  Вот список всех методов объекта список:


.. method:: list.append(x)
   :noindex:

   Добавляет элемент в конец списка.  Эквивалентно ``a[len(a):] = [x]``.


.. method:: list.extend(L)
   :noindex:

   Расширить список, добавив все элементы в данный список. Эквивалентно
   a[len(a):] = L``.


.. method:: list.insert(i, x)
   :noindex:

   Вставить элемент в заданную позицию.  Первый аргумент, это индекс элемента
   перед которым вставлять, так что ``a.insert(0, x)`` вставляет в начало
   cписка, а ``a.insert(len(a), x)`` эквивалентно ``a.append(x)``


.. method:: list.remove(x)
   :noindex:

   Удалить первый элемент из списка, значение которого *х*. Вызовет ошибку в
   случае отсутствия такого элемента.


.. method:: list.pop([i])
   :noindex:

   Удалить элемент в заданной позиции в списке, и возвратить его. Если индекс
   не указан, ``a.pop()`` удаляет и возвращает последний элемент в списке.
   (Квадратные скобки вокруг *i* в сигнатуре метода означают, что параметр
   является необязательным, а не то, что вы должны ввести квадратные скобки
   в этом месте.  Вы будете часто видеть такое обозначение в описании
   библиотеки Python).


.. method:: list.clear()
   :noindex:

   Удалить все элементы из списка. Эквивалентно ``del a[:]``.


.. method:: list.index(x)
   :noindex:

   Возвращает индекс первого элемента в списке, значение которого *x* или
   ошибку, если нет такого элемента.


.. method:: list.count(x)
   :noindex:

   Возвращает число, сколько раз *х* встречается в списке.


.. method:: list.sort(key=None, reverse=False)
   :noindex:


   Сортировать элементы списка (аргументы могут быть использованы для настройки
   сортировки, обратитесь к :func:`sorted` за справкой).


.. method:: list.reverse()
   :noindex:

   Расположить элементы списка в обратном порядке.


.. method:: list.copy()
   :noindex:

   Вернуть неполную копию списка.  Эквивалентно ``a[:]``.


Пример, который использует большинство методов списка::

   >>> a = [66.25, 333, 333, 1, 1234.5]
   >>> print(a.count(333), a.count(66.25), a.count('x'))
   2 1 0
   >>> a.insert(2, -1)
   >>> a.append(333)
   >>> a
   [66.25, 333, -1, 333, 1, 1234.5, 333]
   >>> a.index(333)
   1
   >>> a.remove(333)
   >>> a
   [66.25, -1, 333, 1, 1234.5, 333]
   >>> a.reverse()
   >>> a
   [333, 1234.5, 1, 333, -1, 66.25]
   >>> a.sort()
   >>> a
   [-1, 1, 66.25, 333, 333, 1234.5]
   >>> a.pop()
   1234.5
   >>> a
   [-1, 1, 66.25, 333, 333]

Вы могли заметить, что методы, такие как ``insert``, ``remove`` или ``sort``,
только изменяют имеющийся список им нечего возвращать, они возвращают ``None``
по умолчанию. [1]_  Это принцип конструкции для всех изменяемых структур данных
в Python.


.. _tut-lists-as-stacks:

Использование списков как стеков
--------------------------------

.. sectionauthor:: Ka-Ping Yee <ping@lfw.org>


Методы list делают простой задачей использование списка в качестве стека, где
последний добавленный элемент является первым получаемым элементом ("последний
вошёл, первый вышел (LIFO)").  Чтобы добавить элемент в вершину стека,
используйте :func:`append`. Чтобы получить элемент с вершины стека, используйте
:func:`pop` без явного индекса. Например::

   >>> stack = [3, 4, 5]
   >>> stack.append(6)
   >>> stack.append(7)
   >>> stack
   [3, 4, 5, 6, 7]
   >>> stack.pop()
   7
   >>> stack
   [3, 4, 5, 6]
   >>> stack.pop()
   6
   >>> stack.pop()
   5
   >>> stack
   [3, 4]


.. _tut-lists-as-queues:

Использование списков как очередей
----------------------------------

.. sectionauthor:: Ka-Ping Yee <ping@lfw.org>

Кроме того, можно использовать список в качестве очереди, где первый
добавленный элемент, первым извлекается ("первым вошёл, первым вышел (FIFO)");
Однако, списки не являются эффективными для этой цели. В то время как
добавление или снятие с конца списка быстро, делать вставки или извлечения в
начало списка медленно (потому что все остальные элементы должны быть сдвинуты
на один).

Для реализации очереди, используйте :class:`collections.deque`, которая была
разработана, чтобы быстро добавлять и извлекать с обоих концов. Например::

   >>> from collections import deque
   >>> queue = deque(["Eric", "John", "Michael"])
   >>> queue.append("Terry")           # Terry arrives
   >>> queue.append("Graham")          # Graham прибывает
   >>> queue.popleft()                 # Первый прибывший теперь отходит
   'Eric'
   >>> queue.popleft()                 # Прибывший вторым теперь отходит
   'John'
   >>> queue                           # Оставшаяся очередь в порядке прибыввания
   deque(['Michael', 'Terry', 'Graham'])


.. _tut-listcomps:

Списковые включения
-------------------

Списковые включение предоставляют краткий способ создания списков.  Часто
приложения, создают новые списки, где каждый элемент - результат неких операций
применённых к каждому элементу другой последовательности или итерируемы, или
создают последовательности тех элементов которые отвечают неким условиям.

Например, предположим, что мы хотим создать список квадратов, как:

   >>> squares = []
   >>> for x in range(10):
   ...     squares.append(x**2)
   ...
   >>> squares
   [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

Обратите внимание, что данная операция создаёт (или переписывает) переменную с
именем ``х``, которая остаётся существовать после завершения цикла. Мы можем
вычислить список квадратов без каких-либо побочных эффектов используя::

   squares = list(map(lambda x: x**2, range(10)))

или, что то же самое::

   squares = [x**2 for x in range(10)]

такой способ более краткий и удобочитаемый.

Cписковое включение состоит из скобок содержащих выражение за которым следует
блок :keyword:`for`, затем ноль или более блоков :keyword:`if`. Результатом
станет новый список полученный в результате вычисления выражения в контексте
:keyword:`for` и :keyword:`if` который следует за ним. Например, это
списковключение сочетает в себе элементы двух списков, если они не равны::

   >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
   [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

и это эквивалентно::

   >>> combs = []
   >>> for x in [1,2,3]:
   ...     for y in [3,1,4]:
   ...         if x != y:
   ...             combs.append((x, y))
   ...
   >>> combs
   [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

Обратите внимание, что порядок :keyword:`for` и :keyword:`if` выражений
одинаков в обоих этих примерах.

Если выражение - кортеж (как ``(х, у)`` в предыдущем примере), то оно должно
быть в круглых скобках::

   >>> vec = [-4, -2, 0, 2, 4]
   >>> # создать новый список с удвоенными значениями
   >>> [x*2 for x in vec]
   [-8, -4, 0, 4, 8]
   >>> # отфильтровать отрицательные значения в списке
   >>> [x for x in vec if x >= 0]
   [0, 2, 4]
   >>> # применить функцию ко всем элементам
   >>> [abs(x) for x in vec]
   [4, 2, 0, 2, 4]
   >>> # вызвать метод каждого элемента
   >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
   >>> [weapon.strip() for weapon in freshfruit]
   ['banana', 'loganberry', 'passion fruit']
   >>> # создать список двойных кортежей вроде (number, square)
   >>> [(x, x**2) for x in range(6)]
   [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
   >>> # кортеж должен быть заключён в скобки иначе будет выведена ошибка
   >>> [x, x**2 for x in range(6)]
     File "<stdin>", line 1, in ?
       [x, x**2 for x in range(6)]
                  ^
   SyntaxError: invalid syntax
   >>> # разровнять список используя списковключение с двумя 'for'
   >>> vec = [[1,2,3], [4,5,6], [7,8,9]]
   >>> [num for elem in vec for num in elem]
   [1, 2, 3, 4, 5, 6, 7, 8, 9]

Списковые включения могут содержать сложные выражения и вложенные функции::

   >>> from math import pi
   >>> [str(round(pi, i)) for i in range(1, 6)]
   ['3.1', '3.14', '3.142', '3.1416', '3.14159']

Вложенные списковые включения
-----------------------------

Исходное выражение в списковом включении может быть любое произвольное
выражение, в том числе ещё одно списковое включение.

Рассмотрим следующий пример матрицы 3x4, выполненной в виде списка из 3 списков
длиной в 4 элемента::

   >>> matrix = [
   ...     [1, 2, 3, 4],
   ...     [5, 6, 7, 8],
   ...     [9, 10, 11, 12],
   ... ]

Приведённое ниже описание списка переведёт строки в столбцы::

   >>> [[row[i] for row in matrix] for i in range(4)]
   [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

Как мы видели в предыдущем разделе, вложенное списковключение вычисляется в контексте оператора :keyword:`for` который следует за ним, так что этот пример эквивалентен::

   >>> transposed = []
   >>> for i in range(4):
   ...     transposed.append([row[i] for row in matrix])
   ...
   >>> transposed
   [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

что, в свою очередь, является тем же, что и::

   >>> transposed = []
   >>> for i in range(4):
   ...     # следующие три строки, это вложенное списковлючение
   ...     transposed_row = []
   ...     for row in matrix:
   ...         transposed_row.append(row[i])
   ...     transposed.append(transposed_row)
   ...
   >>> transposed
   [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

В реальном приложении, встроенные функции предпочтительнее, чем сложные
конструкции. Функция :func:`zip` будет крайне полезна в данном случае::

   >>> list(zip(*matrix))
   [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]

Обратитесь к :ref:`tut-unpacking-arguments` чтобы узнать о звёздочке в этой
строке.

.. _tut-del:

Оператор :keyword:`del`
=======================

Существует способ удалить элемент из списка, указав его индекс, а не его
значение: оператор :keyword:`del`. Этот способ отличается от метода
:meth:`pop`, который возвращает значение. Оператор :keyword:`del` также может
быть использован для удаления срезов из списка или очистки списка целиком
(раньше мы делали это присваивая срезу пустой список). Например::

   >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
   >>> del a[0]
   >>> a
   [1, 66.25, 333, 333, 1234.5]
   >>> del a[2:4]
   >>> a
   [1, 66.25, 1234.5]
   >>> del a[:]
   >>> a
   []

:keyword:`del` также может быть использован для удаления переменных::

   >>> del a

С этих пор ссылаться на имя ``a`` ошибка (по крайней мере до тех пор, пока этой
переменной не будет присвоено другое значение), далее мы увидим и другие
применения :keyword:`del`.


.. _tut-tuples:

Кортежи и последовательности
============================

Мы видели, что списки и строки имеют много общих свойств, таких как операции
индексирования и срезы. Они являются примерами типов данных
*последовательность* (см. :ref:`typesseq`).  Поскольку Python --- развивающийся
язык, в него могут быть добавлены и другие последовательные типы данных. Среди
типов данных Python, есть ещё одна последовательность: *кортеж*.

Кортеж состоит из ряда значений, разделённых запятыми, например::

   >>> t = 12345, 54321, 'hello!'
   >>> t[0]
   12345
   >>> t
   (12345, 54321, 'hello!')
   >>> # Кортежи могут могут быть вложенными:
   ... u = t, (1, 2, 3, 4, 5)
   >>> u
   ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
   >>> # Кортежи иммутабельны (неизменяемы):
   ... t[0] = 88888
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: 'tuple' object does not support item assignment
   >>> # но они могут содержать изменяемые объекты:
   ... v = ([1, 2, 3], [3, 2, 1])
   >>> v
   ([1, 2, 3], [3, 2, 1])


Как видите, на выходе кортежи всегда заключаются в круглые скобки, так чтобы
такие, вложенные кортежи правильно интерпретировались; они могут быть введены
со скобками и без, хотя часто скобки необходимы в любом случае (если кортеж
является частью более сложного выражения). Отдельным элементам кортежа нельзя
присваивать значения, однако можно создавать кортежи, содержащие изменяемые
объекты, такие как списки.

Хотя кортежи могут показаться похожими на списки, они часто используются в
других ситуациях и для иных целей. Кортеж :term:`immutable` и обычно содержат
гетерогенную последовательность элементов, доступ к которым можно получить с
помощью распаковки (см. далее в этом разделе) или индексацией (или даже по
атрибуту в случае с :func:`namedtuples <collections.namedtuple>`). Списки
изменяемые (:term:`mutable`) и их элементы, как правило, однородны и доступны с
помощью перебора списка.

Особым случай когда нам нужен кортеж содержащий 0 или 1: синтаксис имеет
дополнительные фишки упрощающие эту задачу.  Пустые кортежи создаются пустой
парой скобок; Кортеж с одним элементом создаётся путём добавления запятой после
элемента (недостаточно просто заключить значение в скобки). Уродливо, но
эффективно.  Например::

   >>> empty = ()
   >>> singleton = 'hello',    # <-- обратите внимание на запятую в конце
   >>> len(empty)
   0
   >>> len(singleton)
   1
   >>> singleton
   ('hello',)

Выражение ``t = 12345, 54321, 'hello!'`` пример *упаковки кортежа*: значения
``12345``, ``54321`` и ``'hello!'`` упакованы в кортеже.  Обратная операция
также возможна::

   >>> x, y, z = t

Это называется, достаточно справедливо, *распаковкой последовательности* и
работает для любой последовательности с правой стороны. Распаковка
последовательности требует, чтобы с левой от знака равенства стороны, было
столько переменных, сколько элементов в последовательности. Обратите внимание,
что множественное присваивание на самом деле просто сочетание упаковки кортежа
и распаковки последовательности.


.. _tut-sets:

Множества
=========

Python также имеет тип данных для *множеств*.  Множество --- неупорядоченная
коллекция без каких-либо повторяющихся элементов.  Основные области применения
включают тестирование членства и устранения дублирующихся записей. Множество
объектов также поддерживают математические операции, такие как объединение,
пересечение, разность и симметрическую разность.

Фигурные скобки или функция :func:`set` могут быть использованы для создания
множеств.  Примечание: чтобы создать пустое множество, вы должны использовать
``set()``, а не ``{}``; последнее создаёт пустой словарь, структуру данных,
которую мы обсудим в следующем разделе.

Вот небольшая демонстрация::

   >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
   >>> print(basket)                     # показать, что дубликаты были удалены 
   {'orange', 'banana', 'pear', 'apple'}
   >>> 'orange' in basket                # быстрая проверка на принадлежность
   True
   >>> 'crabgrass' in basket
   False

   >>> # Продемонстрировать набор операций над буквами из двух миров
   ...
   >>> a = set('abracadabra')
   >>> b = set('alacazam')
   >>> a                                 # уникальные буквы в a
   {'a', 'r', 'b', 'c', 'd'}
   >>> a - b                             # буквы которые есть в a, но нет в b
   {'r', 'd', 'b'}
   >>> a | b                             # букв нет ни в a ни в b
   {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
   >>> a & b                             # буквы есть и в a и в b
   {'a', 'c'}
   >>> a ^ b                             # буквы или в a или в b, но не в обоих
   {'r', 'd', 'b', 'm', 'z', 'l'}

Аналогично :ref:`list comprehensions <tut-listcomps>`, множества поддерживают
вписания::

   >>> a = {x for x in 'abracadabra' if x not in 'abc'}
   >>> a
   {'r', 'd'}


.. _tut-dictionaries:

Словари
=======

Другой полезный тип данных, встроенный в Python --- *словарь* (см.
:ref:`typesmapping`) .  Словари иногда встречаются в других языках в качестве
"ассоциативной памяти" или "ассоциативных массивов". В отличие от
последовательностей, которые индексируются диапазоном чисел, словари
индексируются *ключами*, которые могут быть любого неизменяемого типа; строки и
числа всегда могут быть ключами.  Кортежи могут быть ключами только если они
составлены из строк, чисел или кортежей; Если набор содержит любые изменяемые
объекты, прямо или косвенно, он не может быть использован в качестве ключа. Вы
не можете использовать списки в качестве ключей, так как списки могут быть
изменены на месте используя присвоение по индексу, назначением по срезу, или
такими методами как :meth:`append` и :meth:`extend`.

Лучше всего воспринимать словарь как неупорядоченный набор пар
*ключ: значение*, с требованием, чтобы ключи были уникальны (в пределах одного
словаря). Пара фигурных скобок создаёт пустой словарь: ``{}``. Размещение
разделённого запятыми списка пар ключ: значение внутри скобок добавляет
начальные пары ключ:значение в словарь; это также способ которым словари
выводятся.

Основные операции над словарём хранение значения с каким-либо ключом и
извлечение значения по указанному ключу. Кроме того, можно удалить пару ключ:
значение с помощью ``del``. Если вы сохраняете значение используя ключ, который
уже используется, старое значение, ассоциированное с этим ключом, стирается.
Попытка извлечь значение с помощью несуществующего ключа, вызывает ошибку.

Выполнение ``list(d.keys())`` со словарём возвращает список всех ключей,
использующихся в словаре в произвольном порядке (если вы хотите чтобы он был
отсортирован, просто используйте ``sorted(d.keys()), а)``. [2]_  Для проверки
есть ли ключ есть в словаре, используйте ключевое слово :keyword:`in`.

Вот небольшой пример использования словаря::

   >>> tel = {'jack': 4098, 'sape': 4139}
   >>> tel['guido'] = 4127
   >>> tel
   {'sape': 4139, 'guido': 4127, 'jack': 4098}
   >>> tel['jack']
   4098
   >>> del tel['sape']
   >>> tel['irv'] = 4127
   >>> tel
   {'guido': 4127, 'irv': 4127, 'jack': 4098}
   >>> list(tel.keys())
   ['irv', 'guido', 'jack']
   >>> sorted(tel.keys())
   ['guido', 'irv', 'jack']
   >>> 'guido' in tel
   True
   >>> 'jack' not in tel
   False

Функция :func:`dict` строит словарь непосредственно из последовательностей пар
ключ-значение::

   >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
   {'sape': 4139, 'jack': 4098, 'guido': 4127}

Кроме того, dict вписания могут быть использованы для создания словарей из
произвольных выражений ключ-значение::

   >>> {x: x**2 for x in (2, 4, 6)}
   {2: 4, 4: 16, 6: 36}

Когда ключи простые строки, иногда легче описать пары используя именованные
аргументы::

   >>> dict(sape=4139, guido=4127, jack=4098)
   {'sape': 4139, 'jack': 4098, 'guido': 4127}


.. _tut-loopidioms:

Приёмы с циклами
================

Когда мы проходим циклом по словарю, ключ и соответствующее значение могут быть
получены одновременно, используя метод :meth:`items`::

   >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
   >>> for k, v in knights.items():
   ...     print(k, v)
   ...
   gallahad the pure
   robin the brave

Когда мы проходим циклом по последовательности, индекс позиции и
соответствующее значение могут быть получены одновременно, с помощью функции
:func:`enumerate`::

   >>> for i, v in enumerate(['tic', 'tac', 'toe']):
   ...     print(i, v)
   ...
   0 tic
   1 tac
   2 toe

Чтобы пройти циклом по двум или более последовательностям одновременно, записи
могут быть сопряжены с помощью функции :func:`zip`::

   >>> questions = ['name', 'quest', 'favorite color']
   >>> answers = ['lancelot', 'the holy grail', 'blue']
   >>> for q, a in zip(questions, answers):
   ...     print('What is your {0}?  It is {1}.'.format(q, a))
   ...
   What is your name?  It is lancelot.
   What is your quest?  It is the holy grail.
   What is your favorite color?  It is blue.

Чтобы пройти циклом по последовательности в обратном порядке, сначала задайте
последовательность в прямом направлении, а затем вызовите функцию
:func:`reverse`::

   >>> for i in reversed(range(1, 10, 2)):
   ...     print(i)
   ...
   9
   7
   5
   3
   1

Для прохода по последовательности в отсортированном порядке, используйте
функцию :func:`sorted`, которая возвращает новый отсортированный список,
оставляя исходный неизменным::

   >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
   >>> for f in sorted(set(basket)):
   ...     print(f)
   ...
   apple
   banana
   orange
   pear

Чтобы изменить последовательность которую вы итерируете с помощью while
(например, чтобы продублировать некоторые элементы), рекомендуется сначала
создать копию.  Проход по последовательности создаёт копию неявно.  Нотация
среза делает это особенно удобным::

   >>> words = ['cat', 'window', 'defenestrate']
   >>> for w in words[:]:  # Проход по срезу копии всего списка.
   ...     if len(w) > 6:
   ...         words.insert(0, w)
   ...
   >>> words
   ['defenestrate', 'cat', 'window', 'defenestrate']


.. _tut-conditions:

Подробнее об условиях
=====================

Условия, используемые в инструкциях ``while`` и ``if``, могут содержать другие
операторы, не только сравнения.

Операторы сравнения ``in`` и ``not in`` проверяют встречается ли значение в
последовательности (или не встречается). Операторы, is и not is, пользуются
чтобы определить являются ли два объекта на самом деле одним и тем же объектом;
это применимо только, для изменяемых объектов, таких как списки. Все операции
сравнения имеют одинаковый приоритет, который ниже, чем у всех численных
операторов.

Сравнение могут быть соединены.  Например, ``a < b == c`` проверяет на самом ли
деле a меньше ``b`` и кроме того проверяет если ``b`` равна ``c``.

Сравнения могут быть объединены с помощью логических операторов ``and`` и
``or``, а результат сравнения (или любого другого булева выражения) можно
отрицать с помощью ``not``. Они имеют более низкий приоритет по сравнению с
операторами сравнения; среди них, ``not`` имеет самый высокий приоритет ``and``
и ``or`` низший, так что ``A and B not C`` эквивалентно ``(А and (not В)) or
C``.  Как всегда, круглые скобки могут быть использованы для указания желаемого
приоритета.

Булевы операторы ``and`` и ``or`` --- это так называемые операторы *сокращённого
вычисления*: их параметры вычисляются слева направо, и вычисление
останавливается как только определён его результат. Например, если ``A`` и
``C`` истинны, но B ложно, то ``A and B and C`` не будет вычислять ``C``. В
случае использования значения общего типа, а не булевых, возвращаемым значением
оператора сокращённого вычисления будет последний вычисленный параметр.

Результат сравнения или другого булева выражения может быть присвоен
переменной. Например, ::

   >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
   >>> non_null = string1 or string2 or string3
   >>> non_null
   'Trondheim'

Следует заметить, что в Python, в отличие от C, присваивания не могут
располагаться внутри выражений. Программисты на C могут выражать недовольство
по этому поводу, но это предотвращает появление класса проблем, присущих
C-программам: написание ``=`` в выражении, когда подразумевалось ``==``.


.. _tut-comparing:

Сравнение последовательностей с другими типами данных
=====================================================

Объекты последовательности могут сравниваться с другими объектами с таким же
типом последовательности. Такое сравнение использует *лексикографическую*
сортировку: сначала сравниваются первые два элемента, и, если они различаются,
то это сравнение будет результатом сравнения; если же они равны, то
сравниваются следующие два элемента, и так далее, пока не закончится
последовательность. Если два сравниваемых элемента сами являются
последовательностями одинакового типа, то для них лексикографической сравнение
выполняется рекурсивно. Если все элементы двух последовательностей равны, то
последовательности считаются равными. Если одна последовательность является
частью другой последовательности, то более короткая считается меньшей.
Лексикографическая сортировка для строк использует числовые последовательности
Unicode для сортировки отдельных символов. Вот несколько примеров сравнений
последовательностей одинакового типа::

   (1, 2, 3)              < (1, 2, 4)
   [1, 2, 3]              < [1, 2, 4]
   'ABC' < 'C' < 'Pascal' < 'Python'
   (1, 2, 3, 4)           < (1, 2, 4)
   (1, 2)                 < (1, 2, -1)
   (1, 2, 3)             == (1.0, 2.0, 3.0)
   (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

Следует иметь в виду, что сравнение объектов разного типа при помощи ``<`` или
``>`` приемлемо, при условии, что для этих объектов реализованы соответствующие
методы сравнения.  Например, объекты смешанных числовых типов сравниваются в
соответствии с их числовыми значениями, так 0 равен 0.0, и т.д.  Иначе, вместо
применения произвольной сортировки, интерпретатор будет возбуждать исключение
:exc:`TypeError`.


.. rubric:: Footnotes

.. [1] В других языках может возвращаться изменяемый объект, который разрешает
       вызов цепной методов, такой как 
       ``d->insert("a")->remove("b")->sort();``.

.. [2] Вызов ``d.keys()`` вернёт объект :dfn:`dictionary view`.  Он
       поддерживает операции проверки на принадлежность и итерацию, но его содержимое
       зависит от содержания оригинального словаря -- это только *вид*.

