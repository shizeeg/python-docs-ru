.. _tut-using:

***********************************
Использование интерпретатора Python
***********************************


.. _tut-invoking:

Запуск интепретатора
====================

Интерпретатор Питона обычно устанавливается в :file:`/usr/local/bin/python3.5`

на тех машинах, где он доступен; putting :file:`/usr/local/bin` в $PATH вашей
Unix оболочки вы сможете запускать его, набрав команду:

.. code-block:: text

   python3.5

в консоли. [#]_ Поскольку каталог, в котором обитает интерпретатор, выбирается
в процессе установки, возможны и другие места; свяжитесь с вашим местным Python
гуру или системным администратором. (К примеру, :file:`/usr/local/python`
популярное альтернативное расположение).

На машинах с Windows, установленные файлы Python обычно помещаются в
:file:`C:\\Python35`, хотя вы можете изменить это, после запуска программы
установки. Чтобы добавить эту директорию в ваш "путь", вы можете ввести
следующую команду в командной строке в окно Сеанса MS-DOS::

   set path=%path%;C:\python35

Ввод символа конца файла (:kbd:`Control-D` на Unix, :kbd:`Control-Z` на
Windows) в ответ на первичное приглашение приведёт к выходу из интерпретатора с
нулевым кодом выхода. Если это не работает, вы можете покинуть интерпретатор
набрав следующую команду: ``quit()``.

Возможность интерпретатора редактировать по месту включает в себя интерактивное
редактирование, подстановку из истории, и автодополнение кода в системах с
поддержкой readline. Вероятно, самый быстрый способ проверки, поддерживается ли
правка в командной строке — нажать :kbd:`Control-P` в самой первой строке приглашения
Python. Если раздастся звук, значит правка в командной строке поддерживается;
информацию по клавиатурным сочетаниям смотрите в приложении :ref:`tut-interacting`.
Если же ничего не происходит, или в
ответ появляется ``^P``, значит редактирование в командной строке недоступно;
доступно будет только лишь удаление символов в строке при помощи клавиши
:kbd:`backspace`.

Интерпретатор работает похожим на оболочку Unix образом: при вызове из стандартного
ввода, подключённого к tty-устройству (терминалу), он читает и выполняет команды в
интерактивном режиме; при вызове с именем файла в качестве аргумента или
передачей файла в качестве стандартного ввода, он читает и выполняет *сценарий*
из этого файла.

Второй способ запуска интерпретатора - это запустить команду ``python -c
команда [параметры] ...``, которая выполняет выражения *команда*, аналогично
параметру :option:`-c` в командной оболочке. Так как выражения в Python часто
содержат пробелы, либо специальные, для оболочки, символы, обычно рекомендуется
заключать всю *команду* в одинарные кавычки.

Некоторые модули Питона также полезны в качестве скриптов. Они могут быть
выполнены при помощи команды ``python -m модуль [параметры] ...``, которая
запускает файл исходного кода для *модуля* так, если бы вы указали его полное
имя в командной строке.

Иногда, при выполнении скрипта, полезно запустить скрипт, а затем перейти в
интерактивный режим. Это может быть сделано путём добавления  :option:`-i` перед именем
скрипта.

Все параметры командной строки описаны в разделе :ref:`using-on-general`.


.. _tut-argpassing:

Обработка аргументов
--------------------

Когда интерпретатору известно имя скрипта и дополнительные параметры после него
превращаются в список строк и присваиваются переменной ``argv`` в модуле
``sys``. Вы можете получить доступ к этому списку выполнив ``import sys``.
Список состоит по крайней мере из одного элемента; когда не задан ни один
скрипт и не передан ни один параметр, ``sys.argv[0]`` --— пустая строка. Когда
вместо скрипта указано ``-`` (что означает стандартный ввод), ``sys.argv[0]``
устанавливается в ``-``. При использовании команды :option:`-c`,
``sys.argv[0]`` устанавливается в ``-c``. При использовании :option:`-m`
*модуль*, ``sys.argv[0]`` становится равен полному имени, указанного модуля.
Опции, расположенные после команды :option:`-c` или :option:`-m` *модуль*, не
воспринимаются интерпретатором Python, но остаются в ``sys.argv`` для обработки
командой или модулем.


.. _tut-interactive:

Интерактивный Режим
-------------------

Когда команды читаются из tty (консоли), интерпретатор начинает работать в
*интерактивном режиме*. В этом режиме он запрашивает следующую команду через
*первичное приглашение*, обычно оно выглядит как три знака больше-чем
(``>>>``); для случаев когда команды продолжаются на следующей строке,
интерпретатор выводит вторичное приглашение, обычно это три точки (``...``).
Интерпретатор печатает приветственное сообщение начинающееся с его версии и
сведениях об авторском праве, а позже идёт собственно само приглашение::

   $ python3.5
   Python 3.5 (default, Sep 16 2015, 09:25:04)
   [GCC 4.8.2] on linux
   Type "help", "copyright", "credits" or "license" for more information.
   >>>

.. XXX update for new releases

Вторичное приглашение нужно тогда, когда вводятся много-строчные конструкции.
Как в этом примере, взгляните на этот оператор :keyword:`if`::

   >>> the_world_is_flat = True
   >>> if the_world_is_flat:
   ...     print("Будьте осторожны, не упадите!")
   ...
   Будте осторожны, не упадите!


Более подробно интерактивный режим описан в :ref:`tut-interac`.


.. _tut-interp:

Интерпретатор и его окружение
=============================


.. _tut-source-encoding:

Кодировка в исходном коде
-------------------------

По умолчанию, исходные файлы Python рассматриваются в кодировке UTF-8. В этой
кодировке символы большинства языков мира могут быть использованы одновременно
в строковых литералах, идентификаторах и комментариях --- хотя стандартная
библиотека использует только символы ASCII для идентификаторов, соглашение,
которому должен следовать всякий переносимый код. Для отображения всех этих
символов должным образом, ваш редактор должен поддерживать кодировку UTF-8, и
он должен использовать шрифт, который поддерживает все символы в файле.

Так же возможно указать другую кодировку для исходных файлов. Для того, чтобы
сделать это, поместите ещё один специальный комментарий в строку сразу после
``#!`` строки, для указания кодировки исходного файла::

   # -*- coding: encoding -*-

С этой декларацией, всё в исходном файле будет рассматриваться в кодировке
*encoding* , вместо UTF-8. Список возможных кодировок можно найти в справке по
библиотеке Python, в разделе посвящённом :mod:`codecs`.

Например, если ваш излюбленный редактор не поддерживает файлы в кодировке
UTF-8, и настаивает на использовании какой-либо другой кодировки, скажем,
Windows-1252, вы можете написать::

   # -*- coding: cp-1252 -*-

и теперь использовать все символы в кодировке Windows-1252 в исходных файлах.
Специальное комментарий с кодировкой должен быть *первой или второй строкой* в
файле.


.. rubric:: Footnotes

.. [#] На Unix, интерпретатор Python 3.x по умолчанию не устанавливается с
   исполняемым файлом ``python``, так чтобы не конфликтовать с установленным в
   тоже время Python 2.x.

