.. _tut-informal:

******************************
Неформальное введение в Python
******************************

В примерах представленных в этой главе, ввод и вывод различаются наличием или
отсутствием приглашений (:term:`>>>` и :term:`...`): чтобы повторить пример, вы
должны перепечатать всё, что после приглашения, когда приглашение появится;
строки которые не начинаются с приглашения, это вывод интерпретатора. Обратите
внимание, что вторичное приглашение встречающееся в примерах, за которым ничего
не следует, означает, что вы должны ввести пустую линию; так вы закончите
вводить многострочную команду.

Во многих примерах в данном руководстве, даже в тех, что введены в
интерактивном режиме, содержат комментарии. Комментарии в Питоне начинаются с
символа "решётка" ``#``, и простираются до конца физической строки. Комментарий
может встречаться в начале строки или следовать за пробелом или после кода, но
не в составе строки. ``#`` внутри строки, это всего-лишь символ решётки.
Поскольку комментарии используются для пояснения кода и не интерпретируются
Питоном, они могут быть опущены при перепечатывании примеров.

Несколько примеров::

   # Это первый комментарий
   spam = 1  # а это второй комментарий
             # ... а теперь третий!
   text = "# Это не комментарий, потому что он в кавычках."


.. _tut-calculator:

Использование Python в качестве калькулятора
============================================

Давайте попробуем несколько простых комманд на Питоне. Запустите интепретатор и
подождите первичного приглашения, ``>>>``. (Это не должно занять много
времени).


.. _tut-numbers:

Числа
-----

Интерпретатор действует как простой калькулятор, вы можете ввести выражение и
он выдаст вам значение. Синтакс выражений простой: операторы ``+``, ``-``,
``*`` и ``/`` работают как и в большинстве других языков (например Pascal или
C), круглые скобки (``()``) могут использоваться для группировки. Например::

   >>> 2 + 2
   4
   >>> 50 - 5*6
   20
   >>> (50 - 5*6) / 4
   5.0
   >>> 8 / 5  # деление всегда возвращает число с плавающей запятой
   1.6

Целые числа (например, ``2``, ``4``, ``20``) имеют тип :class:`int`, дробные
(например, ``5.0``, ``1.6``) ``-`` :class:`float`. Далее в этом руководстве мы
узнаем больше о числовых типах.

Деление (``/``) всегда возвращает тип :class:`float`. Для того чтобы получить
:term:`floor division` (округленный результат деления в меньшую сторону), можно
использовать оператор ``//``; чтобы вычислить остаток можно использовать
``%``::

   >>> 17 / 3  # классическое деление возвращает float
   5.666666666666667
   >>>
   >>> 17 // 3  # округлённое деление отбрасывает дробную часть
   5
   >>> 17 % 3  # оператор % возвращает остаток от деления
   2
   >>> 5 * 3 + 2  # результат * делитель + остаток
   17

В Python можно использовать оператор ``**`` для возведения в степень [#]_::

   >>> 5 ** 2  # 5 в квадрате
   25
   >>> 2 ** 7  # 2 в 7-й степени
   128

Знак равенства (``=``) используется для присвоения значения переменной. После этого
результат не отображается до следующего интерактивного приглашения::

   >>> width = 20
   >>> height = 5 * 9
   >>> width * height
   900

Если переменная "необъявлена" (не присвоено значение), попытка использовать её
приведёт к ошибке::

   >>> n  # попытка доступа к необявленной переменной
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   NameError: name 'n' is not defined

Есть полная поддержка чисел с плавающей запятой; операции со смешанными типами
данных приобразуют целочисленный операнд в операнд с плавающей запятой::

   >>> 3 * 3.75 / 1.5
   7.5
   >>> 7.0 / 2
   3.5


В интерактивном режиме, последнее напечатанное выражение присваивается
переменной ``_``. Это означает, что когда вы используете Python в качестве
калькулятора, так отчасти проще продолжать вычисления, например::

   >>> tax = 12.5 / 100
   >>> price = 100.50
   >>> price * tax
   12.5625
   >>> price + _
   113.0625
   >>> round(_, 2)
   113.06


Пользователем эта переменная должна восприниматься как переменная только для
чтения. Не делайте явного присваивания этой переменной --- иначе вы создадите
независимую локальную переменную с таким же именем, скрывающим встроенную
переменную с её особым поведением.


В дополнение к типам :class:`int` и :class:`float`, Python поддерживает работу и с другими
численными типами, как :class:`~decimal.Decimal` и :class:`~fractions.Fraction`. Также в Python есть
встроенная поддержка :ref:`~complex numbers <typesnumeric>`, а также поддержка суффиксов ``j`` или ``J`` для
отображения мнимой части (например ``3+5j``).


.. _tut-strings:

Строки
------

Кроме чисел, Python также может работать со строками, которые могут быть
определены несколькими способами. Строки могу быть заключены в одинарные
кавычки (``'...'``) или в двойные (``"..."``) - результат будет тот же [#]_.
Символ ``\`` может использоваться для экранирования кавычек::

   >>> 'spam eggs'  # одинарные кавычки
   'spam eggs'
   >>> 'doesn\'t'  # используйте \' для экранирования одинарной кавычки...
   "doesn't"
   >>> "doesn't"  # ...или, вместо этого, используйте двойные кавычки
   "doesn't"
   >>> '"Yes," he said.'
   '"Yes," he said.'
   >>> "\"Yes,\" he said."
   '"Yes," he said.'
   >>> '"Isn\'t," she said.'
   '"Isn\'t," she said.'

В интерактивном интерпретаторе выводимая строка заключается в кавычки, а перед
специальными символами ставится обратная косая черта. И хотя иногда это может
отличаться от входных данных (кавычки могут различаться), но эти две строки
эквивалентны. Строка заключается в двойные кавычки в том случае, если она
содержит одинарную кавычку, но не содержит двойных, иначе её заключают в
одинарные кавычки. Функция :func:`print` дает более читаемый вывод отбрасывая
окружающие кавычки и выводя экранированные и специальные символы::

   >>> '"Isn\'t," she said.'
   '"Isn\'t," she said.'
   >>> print('"Isn\'t," she said.')
   "Isn't," she said.
   >>> s = 'First line.\nSecond line.'  # \n знак новой строки
   >>> s  # без print(), \n включается в вывод
   'First line.\nSecond line.'
   >>> print(s)  # вместе с print(), \n производит новую строку
   First line.
   Second line.

Если вы не хотите, чтобы символы, начинающиеся на ``\``, интерпретировались как
специальные, то вы можете использоваться *сырые строки*, добавляя ``r`` перед
открывающей кавычкой::

   >>> print('C:\some\name')  # здесь \n означает новую строку!
   C:\some
   ame
   >>> print(r'C:\some\name')  # обратите внимание на r перед кавычкой
   C:\some\name

Строковые литералы могут занимать несколько строк. Один из способов --—
использование тройных кавычек: ``""" ... """`` или ``''' ... '''``. Символы конца строк
автоматически включаются в строку, но есть возможность предотвратить это,
добавив ``\`` в конец строки. Как в следующем примере::

   print("""\
   Usage: thingy [OPTIONS]
        -h                        Выводит это справочное сообщение
        -H hostname               Имя хоста к которому подключаться
   """)

выводит следующее (обратите внимание, что начальный символ новой строки не
включён в строку):

.. code-block:: text

   Usage: thingy [OPTIONS]
        -h                        Выводит это справочное сообщение
        -H hostname               Имя хоста к которому подключаться

Строки могут быть объединены (склеены между собой) оператором ``+``, а так же
строки можно повторять с помощью оператора ``*``::

   >>> # 3 раза 'un', и далее 'ium'
   >>> 3 * 'un' + 'ium'
   'unununium'

Два или более *строковых литерала* (т.е. то, что заключено в кавычках),
следующие друг за другом, автоматически объединяются::

   >>> 'Py' 'thon'
   'Python'

Однако, это работает только с двумя литералами, не с переменными или
выражениями::

   >>> prefix = 'Py'
   >>> prefix 'thon'  # вы не можете объединять переменную и строку
     ...
   SyntaxError: invalid syntax
   >>> ('un' * 3) 'ium'
     ...
   SyntaxError: invalid syntax

Если вы хотите объединить переменные или константы, используйте ``+``::

   >>> prefix + 'thon'
   'Python'

Эта функция особенно полезна, когда вы хотите разорвать длинные строки::

   >>> text = ('Put several strings within parentheses '
               'to have them joined together.')
   >>> text
   'Put several strings within parentheses to have them joined together.'

Строки могут быть *проиндексированы*, начиная с нуля. Отдельного типа для
символа нет, символ --— просто строка размером в единицу::

   >>> word = 'Python'
   >>> word[0]  # символ в позиции 0
   'P'
   >>> word[5]  # символ в позиции 5
   'n'

Индексы могут также быть отрицательными, для того, чтобы отсчитывать справа::

   >>> word[-1]  # последний символ
   'n'
   >>> word[-2]  # второй с конца символ
   'o'
   >>> word[-6]
   'P'

Отметим, что -0 равен 0, отрицательные индексы начинаются с -1.

В дополнение к индексации, поддерживаются *срезы*. В то время как индексация
используется для получения отдельных символов, *срез* позволяет получить
подстроку::

   >>> word[0:2]  # симвоы с позиции 0 (влючительно) до 2 (исключая)
   'Py'
   >>> word[2:5]  # симвоы с позиции 0 (влючительно) до 5 (исключая)
   'tho'

Обратите внимание, на то начало всегда включается в срез, а конец всегда
исключается. Это гарантирует, что ``s[:i] + s[i:]`` всегда равно ``s``::

   >>> word[:2] + word[2:]
   'Python'
   >>> word[:4] + word[4:]
   'Python'

Индексы среза имеют полезные значения по умолчанию; опущенный первый индекс по
умолчанию равен нулю, опущенный второй индекс по умолчанию --— размер
используемой строки.::

   >>> word[:2]  # символы от начала до поции 2 (исключая)
   'Py'
   >>> word[4:]  # символы от поции 4 (включительно), до конца
   'on'
   >>> word[-2:] # символы от второго с конца символа (включительно), до конца
   'on'

Один из способов запомнить, как работают срезы, это представить, что индексы
указанные *между* символами, с левого края, первый символ под номером 0. Тогда
правый край --- последний символ строки из *n*-символов, имеет индекс *n*,
например::

    +---+---+---+---+---+---+
    | P | y | t | h | o | n |
    +---+---+---+---+---+---+
    0   1   2   3   4   5   6
   -6  -5  -4  -3  -2  -1

Первый ряд чисел даёт позиции индексов в строке 0...6; вторая строка даёт
соответствующие отрицательные индексы. Срез от *i* до *j* состоит из всех символов
между краями обозначенными *i* и *j* соответственно.

Для неотрицательных индексов длина среза, это разность индексов, если оба
находятся в пределах строки. Например, длина ``word[1:3]`` равняется 2.  For
non-negative indices, the length of a slice is the difference of the

Попытка использования слишком большого индекса, приведёт к ошибке::

   >>> word[42]  # word имеет только 6 символов
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   IndexError: string index out of range

Тем не менее, выход за пределы диапазона среза обрабатывается корректно::

   >>> word[4:42]
   'on'
   >>> word[42:]
   ''

Строки в Питоне не могут быть изменены --- они :term:`immutable`
(неизменяемые). Поэтому, присвоение по индеку в строке приводит к ошибке::

   >>> word[0] = 'J'
     ...
   TypeError: 'str' object does not support item assignment
   >>> word[2:] = 'py'
     ...
   TypeError: 'str' object does not support item assignment

Если вам нужна другая строка, вам следует создать новую::

   >>> 'J' + word[1:]
   'Jython'
   >>> word[:2] + 'py'
   'Pypy'

Встроенная функция :func:`len()` возвращает длину строки::

   >>> s = 'supercalifragilisticexpialidocious'
   >>> len(s)
   34


.. seealso::

   :ref:`textseq`
      Строки являются примерами *типов последовательностей*, и поддерживают
      общие операции, поддерживаемые такими типами.

   :ref:`string-methods`
     Строки поддерживают большое количество методов для преобразований и поиска.

   :ref:`string-formatting`
      Информация о форматирования строк с с помощью :meth:`str.format` описана
      здесь.

   :ref:`old-string-formatting`
      Старые операции форматирования вызываются, когда строки и Unicode-строки
      являются левым операндом оператора ``%``, описаны здесь более подробно.


.. _tut-lists:

Списки
------

Python понимает несколько *составных* типов данных, используемых для
группирования других значений. Самый универсальный, это *list* (список),
который может быть записан в виде списка значений (элементов) в квадратных
скобках, разделённых запятыми. Списки могут содержать элементы разных типов, но
обычно все элементы имеют одинаковый тип. ::

   >>> squares = [1, 4, 9, 16, 25]
   >>> squares
   [1, 4, 9, 16, 25]

Как и строки (и все остальные встроенные :term:`sequence`), списки могут быть
проиндексированы и нарезаны::

   >>> squares[0]  # индексация возвращает элемент
   1
   >>> squares[-1]
   25
   >>> squares[-3:]  # срез возвращает новый список
   [9, 16, 25]

Все операции со срезами, везвращают новый список, содержащий запрошенные
элементы. Это означает, что указанный срез возвращает новую копию списка::

   >>> squares[:]
   [1, 4, 9, 16, 25]

Списки также поддерживает такие операции, как конкатенация::

   >>> squares + [36, 49, 64, 81, 100]
   [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

В отличие от иммутабельных строк (:term:`immutable`), списки изменяемый тип
:term:`mutable`, то есть можно их содержимое можно изменять::

    >>> cubes = [1, 8, 27, 65, 125]  # тут что-то не так
    >>> 4 ** 3  # the cube of 4 is 64, not 65!
    64
    >>> cubes[3] = 64  # заменим неправильное значение
    >>> cubes
    [1, 8, 27, 64, 125]

Вы также можете добавлять новые элементы в конец списка, с помощью *метода*
:meth:`~list.append` (мы узнаем о методах подробнее позже)::

   >>> cubes.append(216)  # добавим 6 в кубе
   >>> cubes.append(7 ** 3)  # и добавим 7 в кубе
   >>> cubes
   [1, 8, 27, 64, 125, 216, 343]

Присвоение срезам также возможно, и эта операция может даже изменить размер
списка или очистить его полностью::

   >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
   >>> letters
   ['a', 'b', 'c', 'd', 'e', 'f', 'g']
   >>> # заменим несколько значений
   >>> letters[2:5] = ['C', 'D', 'E']
   >>> letters
   ['a', 'b', 'C', 'D', 'E', 'f', 'g']
   >>> # теперь удалим их
   >>> letters[2:5] = []
   >>> letters
   ['a', 'b', 'f', 'g']
   >>> # cочистим список заменив все его элементы пустым списком
   >>> letters[:] = []
   >>> letters
   []

Встроенная функция :func:`len` также применима к спискам::

   >>> letters = ['a', 'b', 'c', 'd']
   >>> len(letters)
   4

Можно создавать вложенные списки (создавать списки, содержащие другие списки),
например::

   >>> a = ['a', 'b', 'c']
   >>> n = [1, 2, 3]
   >>> x = [a, n]
   >>> x
   [['a', 'b', 'c'], [1, 2, 3]]
   >>> x[0]
   ['a', 'b', 'c']
   >>> x[0][1]
   'b'

.. _tut-firststeps:

Первые шаги на пути к программированию
======================================

Конечно же, мы можем использовать Питон для решения более сложных задач чем
сложение дважды два. Например, мы можем написать программу для вывода ряда
*Фибоначчи*, следующим образом::

   >>> # Ряд Фибоначчи:
   ... # сумма двух элементов определяет следующий
   ... a, b = 0, 1
   >>> while b < 10:
   ...     print(b)
   ...     a, b = b, a+b
   ...
   1
   1
   2
   3
   5
   8

Этот пример знакомит нас с некоторыми новыми возможностями.

* Первая строка содержит *множественное присваивание*: переменные ``a`` и ``b``
  одновременно получают новые значения 0 и 1. На последней строке оно
  используется снова, демонстрируя, что выражения по правую сторону, все
  вычисляются прежде, чем происходит присваивание.  Выражения с правой стороны
  вычисляются слева-направо.

* Ключевое слово :keyword:`while` цикл выполняемый до тех пор, пока условие
  (здесь: ``b < 10``)
  остаётся истинным. В Питоне, как и в C, любое ненулевое целое значение
  является истинным; ноль --- ложным.  Условие также может быть строкой или
  списком, на самом деле любой последовательностью; что угодно ненулевой длинны
  --- истинно, пустая последовательность ложна. В тесте используемом в примере
  --- простое сравнение. Стандартные операторы сравнения пишутся так же, как в C:
  ``<`` (меньше чем), ``>`` (больше чем), ``==`` (равно), ``<=`` (меньше или
  равно), `>=` (больше или равно) и ``!=`` (не равно).

* The *тело* цикла написано с отступом: отступы в Питоне --- способ группировки
  операторов.
  В интерактивном режиме, вам необходимо печатать tab или пробел(ы) в каждой
  строке с отступами.  На практике вы будете подготавливать для Питона более
  сложный ввод, используя текстовый редактор; все современные текстовые редакторы
  имеют возможность авто-отступов.  Когда составное выражение вводится
  интерактивно, за ним должна следовать пустая строка которая говорит о
  завершении (поскольку обработчик не может угадать когда вы напишете последнюю
  строку).  Обратите внимание, что каждая строка в базовом блоке должна содержать
  одинаковое количество отступов.

* Функция :func:`print` выводит значение переданных ей аргументов.
  Это отличается от просто написания выражения которое вы хотите написать (как
  мы делали ранее в примерах с калькулятором), отличается способом обработки
  нескольких аргументов, чисел с плавающей запятой и строк.  Строки выводятся без
  кавычек, и пробел вставляется между элементами, так что вы можете красиво
  форматировать строки, как в следующем примере::

     >>> i = 256*256
     >>> print('The value of i is', i)
     The value of i is 65536

  Специальный аргумент *end* может быть использован для предотвращения
  добавление символа новой строки в конце вывода, или завершения вывода другой
  строкой::

     >>> a, b = 0, 1
     >>> while b < 1000:
     ...     print(b, end=',')
     ...     a, b = b, a+b
     ...
     1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,


.. rubric:: Footnotes

.. [#] Поскольку ``**`` имеет больший приоритет, чем ``-``, ``-3**2`` будет
   интерпретирован как ``-(3**2)`` и поэтому результат будет ``-9``.  Чтобы
   избежать этого и получить результат ``9``, вы можете написать ``(-3)**2``.

.. [#] В отличии от других языков, специальные символы, такие как ``\n`` имеют
   одинаковое значение в одинарных ('''...''') или двойных ("""...""") кавычках.
   Единственное отличие между ними в том, что в одинарных кавычках вам не нужно
   экранировать ``"`` (но нужно экранировать ``\'``) и наоборот.
