.. _tut-classes:

*******
Классы
*******

По сравнению с другими языками программирования, система классов в Python
реализована с минимумом новой семантики и синтаксиса.  Он представляет собой
смесь механизмов классов найденных в C++ и Modula-3.  Классы в Python
предоставляют все стандартные особенности Объектно Ориентированного
Программирования: механизм наследования классов разрешает множественные базовые
классы, наследованный класс может переопределять любой метод своего базового
класса или классов, и метод может вызывать метод базового класса с тем же
именем.  Объекты могут содержать произвольное количество данных любого типа.
Как и модули, классы являются частью динамической природы Python: они создаются
во время выполнения, и могут быть изменены после создания.

В терминологии C++, обычно члены класса (включая члены-данные) являются
открытыми (*public*) (кроме, см. ниже :ref:`tut-private`), а все функции-члены
виртуальными.  Как и в Modula-3, нет сокращений для доступа к членам объекта из
его методов: функция-метод объявляется с явным первым аргументом представляющим
объект, который неявно предоставляется вызовом.  Как и в Smalltalk, классы сами
являются объектами.  Это обеспечивает семантику для импорта и переименования.
В отличие от C++ и Modula-3, встроенные типы могут быть использованы в качестве
базовых классов для расширения пользователем.  Также, как и в C++, большинство
встроенных со специальным синтаксисом (арифметические операторы, операторы
индексирования и т.д.), могут быть переопределены для экземпляров класса.

(Из-за нехватки общепринятой терминологии в разговоре о классах, я буду по
случаю использовать термины Smalltalk и C++. Я бы предпочёл использовать
термины Modula-3, с его объектно-ориентированной семантикой, которая ближе к
Python, чем C++, но я полагаю, что не многие читатели слышали о нем).


.. _tut-object:

Пара слов об именах и объектах
==============================

У объектов есть индивидуальность, и множество имён (во множестве областей
видимости), могут быть связаны с одним объектом. В других языках это называется
псевдонимом. 

Это обычно не ценят при первом знакомстве с Python, и может быть без вреда
проигнорировано при работе с неизменяемыми базовыми типами (числами, строками,
кортежами).  Как бы то ни было, это явление может оказать неожиданное влияние
на семантику кода в Питоне затрагивая изменяемые объекты, как то списки,
словари и большинство других типов.  Это обычно используется для пользы
программы, поскольку псевдонимы, в некотором смысле, ведут себя похожим на
указатели образом.  Например, передача объекта дешёвая операция, поскольку
передаётся только указатель согласно реализации; и если функция изменяет объект
переданный как аргумент, вызывающий увидит изменения --- это отменяет нужду в
двух разных способах передачи параметров, как в Pascal.


.. _tut-scopes:

Области видимости и пространства имён в Python
==============================================

Перед знакомством с классами, я сначала должен рассказать вам кое-что о
правилах видимости в Python.  Определения классов выделывают хитрые штуки с
пространствами имён, и вам нужно знать как работают области видимости и
пространства имён чтобы полностью понимать что происходит.  Впрочем, познания в
этой теме полезны любому продвинутому программисту на Python.

Давайте начнём с некоторых определений.

Пространство имён (*namespace*) это сопоставление имён объектам.  В настоящий
момент, большинство пространств имён реализовано в виде словарей Питона, но
обычно это не заметно во всех смыслах (кроме производительности), и это может
поменяться в будущем.  Примеры пространств имён: набор встроенных имён (включая
функции, такие как :func:`abs`, и имена встроенных исключений); глобальные
имена в модуле; и локальные имена при вызове функции.  В каком-то смысле набор
атрибутов объекта также формирует пространство имён.  О пространствах имён
важно знать то, что нет абсолютно никакой связи между именами в разных
пространствах имён; например, два разных модуля могут определить функцию
``maximize`` без какой-либо путаницы --- пользователи модулей должны указывать
перед функцией имя модуля.

Кстати, Я использую термин *атрибут* для любого имени следующего за точкой ---
например, в выражении ``z.real``, ``real`` это атрибут объекта ``z``.  Строго
говоря, ссылки на имена в модуле и есть ссылки на атрибуты: в выражении
``modname.funcname``, ``modname`` это модуль, а ``funcname`` это его атрибут.
В нашем случае существует прямая связь между атрибутами модуля и глобальными
именами определёнными в модуле: они разделяют общее пространство имён! [#]_

Атрибуты могут быть как только для чтения так и для записи.  В последнем
случае, возможно присвоение атрибуту.  Атрибуты модуля доступны для записи: вы
можете написать ``modname.the_answer = 42``.  Атрибуты доступные для записи
могут быть удалены при помощи оператора :keyword:`del`.  Например, ``del
modname.the_answer`` удалит атрибут :attr:`the_answer` из объекта под именем
``modname``.

Пространства имён создаются в разное время и имеют разную продолжительность
жизни.  Пространство имён содержащее встроенные имена создаётся при запуске
интерпретатора Питона и никогда не удаляется.  Глобальное пространство имён
модуля создаётся в момент чтения определения этого модуля; обычно, пространство
имён модуля "живёт" вплоть до выхода из интерпретатора.  

Выражения выполненные вызовом интерпретатора верхнего уровня, будь то чтение из
файла или интерактивно, рассматриваются как часть модуля названного
:mod:`__main__`, так что у них есть их собственное глобальное пространство
имён.  (На самом деле, в модуле также находятся встроенные имена; они
называются :mod:`builtins`).

Локальное пространство имён для функции создаётся во время вызова функции, и
удаляется когда происходит выход из функции или происходит исключительная
ситуация которая не обрабатывается внутри функции.  (На самом деле, забывается
будет лучшим словом для того чтобы описать, что на самом деле происходит.)
Конечно, рекурсивные вызовы все имеют свои собственные локальные пространства
имён.

Область видимости (*scope*) это регион текста программы на Питоне где
пространство имён доступно напрямую.  "Доступно напрямую" здесь означает, что
явная ссылка на имя приводит к попытке поиска этого имени в этом пространстве
имён.

Хотя области видимости определяются статически, используются они динамически. В
любое время во время исполнения, существует как минимум три вложенных
пространства имён, чти пространства имён доступны напрямую:

* внутренняя область, в которой поиск выполняется в первую очередь, содержит
  локальные переменные
* область любых встроенных функций, которые работают с ближайшими областями,
  содержащими уже не локальные переменные, но и не глобальные.
* предпоследняя область содержит глобальные имена текущего модуля
* внешняя область видимости (просматриваемая последней) - это пространство имен,
  содержащее встроенные имена

Если имя объявлено глобально, тогда все ссылки и присвоения идут прямо в
среднюю область содержащую глобальные имена модуля.  Чтобы переназначить
переменные найденные снаружи самой вложенной области, может быть использован
оператор :keyword:`nonlocal`; если не объявлены нелокально, эти переменные
доступны только для чтения (попытка записи в такую переменную просто приведёт к
созданию *новой* локальной переменной в самой вложенной области, оставляя
одноимённую внешнюю переменную неизменной).

Обычно, локальная область ссылается на локальные имена (буквально) текущей
функции. Снаружи функции, локальная область ссылается на тоже пространство имён
что и глобальная область: пространство имён модуля. Определение класса помещает
ещё одно пространства имён в локальной области.

Важно понимать, что области видимости определены буквально: глобальная область
видимости функции которая определена в модуле и есть область видимости модуля,
в не зависимости от того откуда или как вызван псевдоним функции.  С другой
стороны, поиск имён выполняется динамически, во время выполнения программы ---
однако,язык развивается в сторону статического разрешения имён, во время
"компиляции", так что не опирайтесь на динамическое разрешение имён!  (По сути,
локальные переменные уже определены статически).

Особая причуда Python в том, что -- если оператор :keyword:`global` не имеет
место -- присвоения всегда попадают во внутреннюю область.  Присвоения не
копируют данные --- они просто привязывают имена объектам.  Аналогично для
удалений: выражение ``del x`` удаляет привязку ``x`` из пространства имён на
которую ссылается локальная область видимости.  Фактически, все операции
которые объявляют новые имена используют локальное пространство имён: в
частности, выражения :keyword:`import` и определения функций связывают имя
модуля или функции в локальном пространстве имён.

Ключевое слово :keyword:`global` может быть использовано для указания того, что
конкретные переменные живут в глобальном пространстве имён и должны
переназначаться там;  Ключевое слово :keyword:`nonlocal` указывает на то, что
конкретные переменные живут в прилегающей области видимости и должны
переназначаться там.

.. _tut-scopeexample:

Примеры пространств имён и областей видимости
---------------------------------------------

Это пример демонстрирующий как ссылаться на различные области видимости и
пространства имён, и как :keyword:`global` и :keyword:`nonlocal` влияют на
связывание переменных::


   def scope_test():
       def do_local():
           spam = "local spam"
       def do_nonlocal():
           nonlocal spam
           spam = "nonlocal spam"
       def do_global():
           global spam
           spam = "global spam"
       spam = "test spam"
       do_local()
       print("После local присвоения:", spam)
       do_nonlocal()
       print("После nonlocal присвоения:", spam)
       do_global()
       print("После global присвоения:", spam)

   scope_test()
   print("В global области видимости:", spam)

Этот пример выводит:

.. code-block:: none

   После local присвоения: test spam
   После nonlocal присвоения: nonlocal spam
   После global присвоения: nonlocal spam
   В global области видимости: global spam

Обратите внимание как *local* присвоение (присвоение по умолчанию) не меняет
связывание *scope_test*\'a со *spam*.  :keyword:`nonlocal` присвоение изменяет
связывание *scope_test*\'а со *spam*, и :keyword:`global` присвоение меняет
связывание уровня модуля.

Так же вы можете видеть, что никакого предварительного связывания *spam* до
:keyword:`global` присвоения нет.


.. _tut-firstclasses:

Первый взгляд на классы
=======================

В классах мы знакомимся с небольшим количеством нового синтаксиса, тремя новыми
типами объектов, и небольшим количеством новой семантики.


.. _tut-classdefinition:

Синтаксис определения класса
----------------------------

Простейшая форма определения класса выглядит так::

   class ИмяКласса:
       <выражение-1>
       .
       .
       .
       <выражение-N>

Определение классов, как и определение функций (:keyword:`def` выражения)
должны быть выполнены, прежде чем они возымеют какой-то эффект.  (Вы можете
поместить определение класса в ветку оператора оператора :keyword:`if`, или
внутри функции).

На практике, выражения внутри определения класса, это обычно определения
функций, но разрешены и другие выражения (в т.ч. матерные), что бывает полезно
--- мы вернёмся к этому позже.  Определения функций внутри класса, обычно имеют
особую форму списка параметров, продиктованную соглашениями вызова методов ---
опять же, об этом будет рассказано позже.

При вхождении в определение класса, создаётся новое пространство имён, и
используется оно как локальная область видимости --- поэтому, все присвоения
локальным переменным идут в этой новой области имён.  В частности, определения
функций связывают имена новых функций там же.

Когда происходит выход из определения класса (обычно при достижении end, a
создаётся *объект класса*.  Это в основном обёртка вокруг содержания
пространства имён созданного определением класса; мы узнаем больше об объектах
класса в следующем разделе.  Оригинальная локальная область видимости (которая
была активна непосредственно перед вхождением в объявление класса) становится
активной снова, и объект класса привязывается к имени класса указанному в
определении класса тут, в заголовке определения класса (:class:`ClassName` в
нашем примере).


.. _tut-classobjects:

Объекты класс
-------------

Объекты типа класс поддерживают два вида операций: ссылки на атрибуты и
инициализацию.

*Ссылки на атрибуты* используют стандартный синтаксис используемый для всех
ссылок на атрибуты в Питоне: ``obj.name``.  Корректные имена атрибутов, это все
имена, которые были в пространстве имён класса в момент когда был создан объект
этого класса.  Так что, если определение класса выглядит так::

   class MyClass:
       """Простой пример класса"""
       i = 12345
       def f(self):
           return 'привет, мир'

тогда ``MyClass.i`` и ``MyClass.f`` корректные ссылки на атрибуты, возвращающие
целое и объект функцию соответственно. Атрибутам класса так же можно
присваивать, так что вы можете менять значение ``MyClass.i`` присвоением.
:attr:`__doc__` так же корректный атрибут, возвращающий текст документации
принадлежащий классу: ``"Простой пример класса"``.

При *создании экземпляра класса* используется функциональная нотация.  Просто
представьте, что объект класса это функция без параметров которая возвращает
новый экземпляр класса.  Например, возьмём класс выше::

   x = MyClass()

создаёт новый *экземпляр* класса и присваивает этот объект локальной переменной
``x``.

Операция создания экземпляра класса ("вызов" объекта класс), создаёт пустой
объект.  Многие классы создают объекты с экземплярами настроенными на
определённое начальное состояние. Поэтому класс может определить специальный
метод называющийся :meth:`__init__`, как-то так::

   def __init__(self):
       self.data = []

Когда класс определяет метод :meth:`__init__`, при создании экземпляра класса
метод :meth:`__init__` автоматически вызывается для вновь созданного экземпляра
класса.  Как в этом примере, новый экземпляр класса может быть получен таким
образом::

   x = MyClass()

Конечно же, метод :meth:`__init__` может иметь параметры для большей гибкости.
В этом случае, параметры переданные оператору создания экземпляра класса,
предаются в :meth:`__init__`.  Например, ::

   >>> class Complex:
   ...     def __init__(self, realpart, imagpart):
   ...         self.r = realpart
   ...         self.i = imagpart
   ...
   >>> x = Complex(3.0, -4.5)
   >>> x.r, x.i
   (3.0, -4.5)


.. _tut-instanceobjects:

Объекты экземпляров
-------------------

Теперь, что мы можем делать с объектами экземпляров?  Единственная операция
доступная для объектов экземпляров, это ссылки на атрибуты.  Есть два вида
допустимых имён атрибутов, атрибуты данных и методы.

*атрибуты данных* похожи на "переменные экземпляров" в Smalltalk, и на "члены
данных" в C++.  Атрибуты данных не нужно объявлять; как и локальные переменные,
они появляются на свет когда происходит первое присвоение.  Например, если
``x`` это экземпляр :class:`MyClass` созданный выше, следующий отрывок кода
выведет значение ``16``, без оставления следа::

   x.counter = 1
   while x.counter < 10:
       x.counter = x.counter * 2
   print(x.counter)
   del x.counter

Ещё один вид ссылки атрибута экземпляра, это *method*. Метод это функция
"принадлежащая" объекту.  (В Python, термин метод применяется не только для
экземпляров классов: другие типы объектов также могут иметь методы.  Например,
объекты список имеют методы: append, insert, remove, sort, и т.д.  Однако, в
дальнейшем, мы будем использовать термин метод исключительно в значении методы
объекта экземпляра класса класса, если не указано иначе).

.. index:: object: method

Допустимые имена методов объекта экземпляра зависят от его класса.  По
определению, все атрибуты класса, которые являются объектами функция определяют
соответствующие методы их экземпляров.  В нашем примере, ``x.f`` допустимая
ссылка на метод, т.к. ``MyClass.f`` это функция, но ``x.i`` нет, т.к.
``MyClass.i`` не функция.  Но ``x.f`` не то же самое, что ``MyClass.f`` --- это
*объект метод*, а не объект функция.


.. _tut-methodobjects:

Объекты метод
-------------

Обычно, метод вызывается сразу после его связи::

   x.f()

В примере :class:`MyClass`, это вернёт строку ``'привет, мир'``.  Однако, это
не обязательно вызовет метод: ``x.f`` это объект метода, и может быть сохранён
и вызван позже.  Например::

   xf = x.f
   while True:
       print(xf())

будет продолжать печатать ``привет, мир`` до скончания времён.

Что конкретно происходит при вызове метода?  Вы могли заметить, что ``x.f()``
был вызван без параметра сверху, даже не смотря на то, что объявление для
:meth:`f` указывает параметр.  Что же произошло с параметром?  Конечно же
Python выбросит исключение когда функция требующая наличия параметра будет
вызвана без всяких параметров --- даже если параметр на самом деле не
используется...

На самом деле вы уже могли догадаться: методы - особый случай, когда объект
передаётся в качестве первого параметра функции.  В нашем примере, вызов
``x.f()`` полностью идентичен ``MyClass.f(x)``.  Обычно, вызов метода со
списком из *n* параметров эквивалентен вызову соответствующей функции со
списком параметров который создан подстановкой объекта метода в качестве
первого аргумента.


Если вы не понимаете как работают методы, посмотрите на реализацию и, возможно,
картина прояснится.  Когда происходит ссылка на экземпляр атрибута, выполняется
поиск не в его данных, а в его классе.  Если имя указывает на корректный
атрибут класса который является объектом функция, создаётся объект метод путём
упаковки (указания на) объект экземпляр и объект функция тут же находятся
вместе в абстрактном объекте: это есть объект метод.  Когда объект метод вызван
со списком параметров, создаётся новый список параметров из экземпляра объекта
и списка параметров, и объект функция вызывается с этим новым списком
параметров.


.. _tut-class-and-instance-variables:

Переменные экземпляра и класса
------------------------------

Вообще говоря, переменные экземпляра предназначены для данных уникальных для
каждого экземпляра и переменные класса предназначены для атрибутов и методов
общих для всех экземпляров класса::

    class Dog:

        kind = 'canine'         # переменная класса общая для всех экземпляров

        def __init__(self, name):
            self.name = name    # переменная экземпляра уникальная для каждого
                                # экземпляра

    >>> d = Dog('Fido')
    >>> e = Dog('Buddy')
    >>> d.kind                  # общая для всех собак
    'canine'
    >>> e.kind                  # общая для всех собак
    'canine'
    >>> d.name                  # уникальная для d
    'Fido'
    >>> e.name                  # уникальная для e
    'Buddy'

Как обсуждалось в :ref:`tut-object`, общие данные могут иметь, возможно
неожиданные эффекты когда задействованы :term:`mutable` объекты такие как
списки и словари.  Например, список *tricks* в коде ниже не должен быть
использован как переменная класса потому что этот один список будет общим всеми
экземплярами *Dog*::

    class Dog:

        tricks = []             # ошибочное использвание переменной класса

        def __init__(self, name):
            self.name = name

        def add_trick(self, trick):
            self.tricks.append(trick)

    >>> d = Dog('Fido')
    >>> e = Dog('Buddy')
    >>> d.add_trick('roll over')
    >>> e.add_trick('play dead')
    >>> d.tricks                # неожиданно общий для всех собак
    ['roll over', 'play dead']

Корректный дизайн этого класса должен использовать экземпляр переменной вместо
этого::

    class Dog:

        def __init__(self, name):
            self.name = name
            self.tricks = []    # создаёт новый пустой список для каждой собаки

        def add_trick(self, trick):
            self.tricks.append(trick)

    >>> d = Dog('Fido')
    >>> e = Dog('Buddy')
    >>> d.add_trick('roll over')
    >>> e.add_trick('play dead')
    >>> d.tricks
    ['roll over']
    >>> e.tricks
    ['play dead']


.. _tut-remarks:

Случайные замечания
===================

.. These should perhaps be placed more carefully...

Атрибуты данных переопределяют атрибуты методов с совпадающим именем; чтобы
предотвратить случайные конфликты имён, которые могут привести к ошибкам
которые весьма сложно найти в больших программах, мудро использовать некое
соглашение, что позволит минимизировать случаи конфликтов.  

Возможные соглашения включают именование методов с заглавной буквы, начинать
имена атрибутов данных с короткой уникальной строки (возможно просто с
подчёркивания), или используя глаголы для методов и существительные для
атрибутов данных.

На атрибуты данных могут ссылаться как методы, так и обычные пользователи
("клиенты") объекта.  Другими словами, классы не могут быть использованы для
реализации чисто абстрактный типов данных. На самом деле ничто в Питоне не
делает возможным принудительное скрытие данных --- это всё основывается на
соглашении.  (С другой стороны, реализация Python написанная на C, способна
полностью скрыть детали реализации и управление объектами, если необходимо; это
может быть использовано расширениями Питона написанными на C).

Клиентам следует использовать атрибуты данных с осторожностью --- clients may
mess up invariants maintained by the methods by stamping on their data
attributes.  Обратите внимание, что клиенты могут добавлять свои собственные
атрибуты данных экземпляру объекта не затрагивая корректность методов, до тех
пор пока не произошло конфликта имён --- опять же, соглашение об именовании
может уберечь вас от множества проблем.

Не существует быстрого способа ссылаться на атрибуты данных (или другие
методы!) внутри методов.  Я нахожу, что это повышает читаемость методов: нет
шанса перепутать локальные переменные и переменные экземпляра во время чтения
кода метода.

Часто, первый параметр метода называется ``self``.  Это ничто иное как
соглашение: имя ``self`` не имеет никакого особого значения для Python.
Обратите внимание, однако, если не следовать этому соглашению ваш код может
стать менее читаемым для других программистов на Python, и что так же очевидно,
что *class browser*  может рассчитывать на такое соглашение.

Любой объект функция, который является атрибутом класса определяет метод для
экземпляра этого класса.  Не обязательно, чтобы определение функции фактически
находилось внутри определения класса: присвоение объекта функция локальной
переменной в классе вполне допустимо.  Например::

   # Функция определена за пределами класса
   def f1(self, x, y):
       return min(x, x+y)

   class C:
       f = f1
       def g(self):
           return 'hello world'
       h = g

Теперь ``f``, ``g`` и ``h`` все являются атрибутами класса :class:`C` которые
ссылаются на объекты функция, и следовательно они все --- методы экземпляров
класса :class:`C` --- ``h`` абсолютно идентичен ``g``.  обратите внимание, что
такая практика обычно только запутывает читающего программу.

Методы могут вызывать другие методы используя атрибуты параметра ``self``::

   class Bag:
       def __init__(self):
           self.data = []
       def add(self, x):
           self.data.append(x)
       def addtwice(self, x):
           self.add(x)
           self.add(x)

Методы могут ссылаться на глобальные переменные тем же образом, каким и на
обычные функции.  Глобальная область видимости ассоциированная с методом
является модулем содержащим его определение.  (Класс никогда не использует
глобальное пространство имён).  Пока кто-нибудь не столкнётся с редкой
необходимостью использовать глобальные данные в методе, существует множество
законных пользователей глобального пространства имён: как минимум, функции и
модули импортированные в глобальное пространство имён могут использоваться
методами, так же как и функциями и классами определёнными в них.  Обычно, класс
содержит метод, который сам определён в глобальном пространстве имён, и в
следующем разделе мы узнаем веские причины того, почему методу может
понадобиться ссылаться на собственный класс.

Каждое значение это объект, и поэтому имеет *класс* (также называемый его
*типом*).  Он хранится в ``object.__class__``.


.. _tut-inheritance:

Наследование
============

Конечно же, возможность языка не стоило бы называть "класс" без поддержки
наследования.  Синтаксис определения наследованного класса выглядит примерно
так::

   class ИмяНаследуемогоКласса(ИмяБазовогоКласса):
       <выражение-1>
       .
       .
       .
       <выражение-N>

Имя класса :class:`ИмяБазовогоКласса` должно быть определено в области
видимости содержащей определение наследуемого класса.  Вместо имени базового
класса, так же допустимы другие произвольные выражения.  Это может оказаться
полезным, например, например когда базовый класс определён в другом модуле::

   class ИмяНаследуемогоКласса(имямодуля.ИмяБазовогоКласса):

Выполнение определения наследуемого класса происходит так же как и для базового
класса.  Когда объект класса построен, базовый класс запоминается.  Это
используется для разрешения ссылок на атрибуты: если запрашиваемый атрибут не
найден в классе, поиск продолжается в базовом классе.  Это правило применяется
рекурсивно если базовый класс сам по себе наследован от какого-то иного класса.

Нет ничего особенного в создании экземпляра наследованных классов:
``ИмяНаследованногоКласса()`` создаёт новый экземпляр класса.  Ссылки на методы
разрешаются следующим образом: ищется соответствующий атрибут класса, спускаясь
по цепи базовых классов, если необходимо, и ссылка на метод корректна если это
приводит к объекту функция.

Наследованные классы могут переназначать методы своих базовых классов.  Потому
что методы не имеют специальных привилегий когда вызывают другие методы того же
объекта, метод базового класса который вызывает другой метод определённый в том
же базовом классе может привести к вызову метода наследованного класса который
переназначает его.  (Для C++ программистов: все методы в Питоне эффективно
``виртуальные``).

Переназначение метода в наследованном классе может по факту расширять нежели
просто заменять метод базового класса с тем же именем. Существует простой
способ вызова метода базового класса напрямую: просто вызывая
``ИмяБазовогоКласса.имяметода(self, параметры)``.  Это так же иногда полезно и
для клиентов.  (Обратите внимание что это работает только если базовый класс
доступен как ``ИмяБазовогоКласса`` в глобальной области видимости).

Python имеет две встроенные функции которые работают с наследованием:

* Используйте :func:`isinstance` чтобы проверить тип экземпляра:
  ``isinstance(obj, int)`` будет ``True`` только если ``obj.__class__``
  является :class:`int` или каким-либо классом наследованным от :class:`int`.

* Используйте :func:`issubclass` чтобы проверить экземпляр класса:
  ``issubclass(bool, int)`` выдаст ``True`` т.к. :class:`bool` является
  подклассом :class:`int`.  Однако, ``issubclass(float, int)`` выдаст ``False``
  т.к. :class:`float` не является подклассом :class:`int`.



.. _tut-multiple:

Множественное наследование
--------------------------

Python так же поддерживает форму множественного наследования.  Определение
класса с несколькими базовыми классами выглядит так::

   class ИмяНаследованногоКласса(Базовый1, Базовый2, Базовый3):
       <выражение-1>
       .
       .
       .
       <выражение-N>

Для большинства применений, в простейших случаях, вам можете подумать о поиске
атрибутов наследованных от родительского класса как нижний первый,
слева-направо, не искать дважды в одном и том же классе где нет перехлёста в
иерархии.  Увы, если атрибут не найден в классе
:class:`ИмяНаследованногоКласса`, оно искало в классе :class:`Базовый1`, затем
(рекурсивно) в базовых классах :class:`Базовый1`, и если не найдено там, оно
искало в :class:`Базовый2`, и т.д.

По факту, этот процесс несколько сложнее; порядок разрешения метода изменяется
динамически чтобы поддерживать кооперативные вызовы :func:`super`.  Этот подход
в некоторых языках со множественным наследованием известен как
вызов-следующего-метода (call-next-method) и является более мощным, чем супер
вызов, который можно найти в языках с одиночным наследованием.

Динамический порядок необходим потому что все случаи множественного
наследования демонстрируют один или более ромбовидных отношений (где хотя бы к
одному из родительских классов доступ может быть получен несколькими путями из
самого нижнего класса).  Например, все классы наследуются от :class:`object`,
так что в любом случае множественное наследование предоставляет более одного
пути чтобы достигнуть :class:`object`.  Чтобы не допустить доступа к базовым
классам более одного раза, динамический алгоритм линеаризует порядок поиска так
чтобы сохранить порядок слева-направо указанный в каждом классе, который
вызывает каждого родителя только один раз, и это монотонно (это означает, что
класс может быть наследован не затрагивая порядок в котором расположены его
родители). Собранные вместе, эти свойства делают возможным разработку надёжных
и расширяемых классов с множественным наследованием.  За подробной справкой,
обращайтесь https://www.python.org/download/releases/2.3/mro/.


.. _tut-private:

Приватные переменные
====================

"Приватные" переменные экземпляра те к которым нет доступа ниоткуда, кроме как
изнутри объекта --- не существуют в Питоне.  Однако, есть соглашение которому
следует большинство кода на Питоне: имя начинающееся со знака подчёркивания
(например, ``_spam``) следует воспринимать как не-публичную часть API (будь то
функция, метод или член данных).  Это следует воспринимать как особенности
реализации и то, что может измениться без предупреждения.

Поскольку существует корректный способ применения приватных переменных класса
(например, для предотвращения конфликта имён с именами определёнными в
подклассах), существует ограниченная поддержка такого механизма как :dfn:`name
mangling`.  Любой идентификатор вида ``__spam`` (как минимум два символа
подчёркивания и хотя бы один такой символ в конце) буквально заменяется на
``_classname__spam``, где ``classname`` это текущее имя класса из имени
которого убран предшествующий знак(и) подчёркивания.  This mangling сделано без
учёта синтаксического положения этого идентификатора, до тех пор пока он
встречается в определении класса.

Name mangling чтобы позволять подклассам переопределять методы без нарушения
интраклассового вызова методов.  Например::

   class Mapping:
       def __init__(self, iterable):
           self.items_list = []
           self.__update(iterable)

       def update(self, iterable):
           for item in iterable:
               self.items_list.append(item)

       __update = update   # приватная копия оригинального метода update()

   class MappingSubclass(Mapping):

       def update(self, keys, values):
           # предоставляет новую подпись для update()
           # но не ломает __init__()
           for item in zip(keys, values):
               self.items_list.append(item)

Note that the mangling rules are designed mostly to avoid accidents; it still is
possible to access or modify a variable that is considered private.  This can
even be useful in special circumstances, such as in the debugger.

Notice that code passed to ``exec()`` or ``eval()`` does not consider the
classname of the invoking class to be the current class; this is similar to the
effect of the ``global`` statement, the effect of which is likewise restricted
to code that is byte-compiled together.  The same restriction applies to
``getattr()``, ``setattr()`` and ``delattr()``, as well as when referencing
``__dict__`` directly.


.. _tut-odds:

Всякая всячина
==============

Иногда бывает полезно иметь тип данных похожий на "record" в Pascal или
"struct" в C, собрать вместе несколько именованных элементов данных.  Пустой
класс прекрасно подойдёт::

   class Employee:
       pass

   john = Employee() # Создадим пустую запись о сотруднике

   # Заполним поля этой записи
   john.name = 'Вася Пупкин'
   john.dept = 'IT отдел'
   john.salary = 1000

Куску кода на Питоне который ожидает особый абстрактный тип данных часто может
быть передан класс который эмулирует методы этого типа данных.  Допустим, если
у вас есть функция которая форматирует некие данные из объекта файл, вы можете
определить класс с методами :meth:`read` и :meth:`!readline` который берёт
данные из стокового буфера, и передаёт их в качестве параметра.

.. (К сожалению, у этого способа есть свои недостатки: класс не может
    определить операции доступ к которым осуществляется через специальный
    синтаксис, вроде регионов или арифметических опрераторов, и присвоение
    такого "псеввдо-файла" sys.stdin не заставит интерпретатор читать данные из
    него).

Методы объекта экземпляра тоже имеют атрибуты: ``m.__self__`` это объект
экземпляра с методом :meth:`m`, а ``m.__func__`` это объект функция
соответствующая этому методу.


.. _tut-exceptionclasses:

Исключения это тоже классы
==========================

Определённые пользователем исключения тоже представляют из себя классы.
Используя этот механизм возможно создать расширяемые иерархии исключений.

Вот две новые (семантические) формы выражения :keyword:`raise`::

   raise Class

   raise Instance

В первой форме, ``Class`` должен быть экземпляром :class:`type` или класса
наследованного от него.  Первая форма -- краткая запись для::

   raise Class()

Класс в блоке :keyword:`except` совместим с исключением если тот же класс или
его базовый класс (но тут нет другого пути --- блок except в котором перечислен
наледованный класс несовместим с базовым классом).  Например, следующий код
выведет B, C, D в указанном порядке::

   class B(Exception):
       pass
   class C(B):
       pass
   class D(C):
       pass

   for cls in [B, C, D]:
       try:
           raise cls()
       except D:
           print("D")
       except C:
           print("C")
       except B:
           print("B")

Обратите внимание, что если перевернуть (поставить ``except B`` первым), код
напечатает B, B, B --- первый подходящий блок except clause сработает.

Когда выводится сообщение об ошибке о необработанном исключении, выводится имя
класса исключения, зачем двоеточие и пробел, и наконец экземпляр
преобразованный в строку используя встроенную функцию :func:`str`.


.. _tut-iterators:

Итераторы
=========

К данному моменту вы, возможно, успели заметить что большинство объектов
контейнеров могут быть пройдены в цийве используя оператор :keyword:`for`::

   for element in [1, 2, 3]:
       print(element)
   for element in (1, 2, 3):
       print(element)
   for key in {'один':1, 'два':2}:
       print(key)
   for char in "123":
       print(char)
   for line in open("myfile.txt"):
       print(line, end='')

Этот способ доступа ясен, понятен и удобен.  Использование итераторов
пронизывает и унифицирует Python.  Внутри, оператор :keyword:`for` вызывает
:func:`iter` на объекте контейнера.  Эта функция возвращает объект итератор
который определяет метод :meth:`~iterator.__next__` который получает доступ к
элементам в контейнере по одному раз раз.  Когда больше не остаётся элементов,
:meth:`~iterator.__next__` выбрасывает исключение :exc:`StopIteration` которое
заставляет цикл оператора :keyword:`for` прекратиться.  Вы можете вызвать метод
:meth:`~iterator.__next__` используя встроенную функцию :func:`next`; в этом
примере показано как всё это работает::

   >>> s = 'abc'
   >>> it = iter(s)
   >>> it
   <iterator object at 0x00A1DB50>
   >>> next(it)
   'a'
   >>> next(it)
   'b'
   >>> next(it)
   'c'
   >>> next(it)
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
       next(it)
   StopIteration

Теперь, когда вы увидели механику стоящую за протоколом итератора, очень легко
добавить поведение итератора вашим классам.  Определите метод :meth:`__iter__`
который возвращает объект с методом :meth:`~iterator.__next__`.  Если этот
класс определяет :meth:`__next__`, то :meth:`__iter__` может просто возващать
``self``::

   class Reverse:
       """Итератор для прохождения последовательности назад."""
       def __init__(self, data):
           self.data = data
           self.index = len(data)
       def __iter__(self):
           return self
       def __next__(self):
           if self.index == 0:
               raise StopIteration
           self.index = self.index - 1
           return self.data[self.index]

::

   >>> rev = Reverse('spam')
   >>> iter(rev)
   <__main__.Reverse object at 0x00A1DB50>
   >>> for char in rev:
   ...     print(char)
   ...
   m
   a
   p
   s


.. _tut-generators:

Генераторы
==========

:term:`Generator`\ы простой но мощный инструмент для создания итераторов.  Они
пишутся как обычные функции но используют оператор :keyword:`yield` там где
возвращают данные.  Каждый раз когда функция :func:`next` вызывается на них,
генератор продолжает работу с того места где остановился (он запоминает все
данные и какой оператор был выполнен последним).  Пример показывает насколько
просто и легко могут быть созданы такие генераторы::

   def reverse(data):
       for index in range(len(data)-1, -1, -1):
           yield data[index]

::

   >>> for char in reverse('golf'):
   ...     print(char)
   ...
   f
   l
   o
   g

Всё, что может быть сделано при помощи генераторов, так же может быть сделано с
помощью основанных на классах итераторах как описано в предыдущем разделе.  Что
делает генераторы такими компактными, это то, что методы :meth:`__iter__` и
:meth:`~generator.__next__` создаются автоматически.

Другая ключевая особенность это то, что локальные переменные и состояние
выполнения автоматически сохраняются между вызовами.  По этой причине функции
становится легче писать и они получаются намного чище, чем при использовании
переменных экземпляра вроде ``self.index`` и ``self.data``.

В дополнение к автоматически создающимся методам и сохранению состояния
программы, когда генераторы уничтожаются, они автоматически выбрасывают
:exc:`StopIteration`. В купе, эти возможности облегчают создание итераторов
требующих больше усилий, чем обычные функции.


.. _tut-genexps:

Выражения генераторов
=====================

Некоторые простые генераторы могут быть написаны кратко как выражения используя
синтаксис похожий на вписанные списки, но со круглыми скобками вместо
квадратных.  Эти выражения разработаны для ситуаций, когда генератор
используется прямо в прилегающей функции.  Выражения генераторов более
компактны, но менее универсальны чем полноценные описания генераторов и чаще
менее требовательны к памяти чем эквивалентные вписанные списки.

Примеры::

   >>> sum(i*i for i in range(10))                 # сумма квадратов
   285

   >>> xvec = [10, 20, 30]
   >>> yvec = [7, 5, 3]
   >>> sum(x*y for x,y in zip(xvec, yvec))         # произведение векторов
   260

   >>> from math import pi, sin
   >>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}

   >>> unique_words = set(word  for line in page  for word in line.split())

   >>> valedictorian = max((student.gpa, student.name) for student in graduates)

   >>> data = 'golf'
   >>> list(data[i] for i in range(len(data)-1, -1, -1))
   ['f', 'l', 'o', 'g']



.. rubric:: Footnotes

.. [#] Кроме одного случая.  Объекты модулей имеют секретный атрибут только для
   чтения который называется  :attr:`__dict__` который возвращает словарь
   использующийся в реализации пространства имён модуля; имя :attr:`__dict__`
   это атрибут, а не глобальное имя.
   Очевидно, его использование нарушает абатстракцию реализации пространства
   имён, и должно быть ограничено вещами вроде отладчиков.

