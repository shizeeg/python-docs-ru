.. _tut-morecontrol:

*****************************************************
Больше инструментов контроля хода выплнения программы
*****************************************************

Кроме только что описанного оператора :keyword:`while`, Python имеет
представление о привычных операторах, управляющих порядком выполнения
программы, известных из других языков, с некоторыми особенностями.


.. _tut-if:

Оператор :keyword:`if` 
======================

Пожалуй, наиболее хорошо известный тип оператора --- это оператор
:keyword:`if`. Например::

   >>> x = int(input("Пожалуйста введите целое число: "))
   Пожалуйста введите целое число: 42
   >>> if x < 0:
   ...     x = 0
   ...     print('Отрицательное изменено на ноль')
   ... elif x == 0:
   ...     print('Ноль')
   ... elif x == 1:
   ...     print('Единица')
   ... else:
   ...     print('Больше')
   ...
   Больше

Здесь может быть ноль или более блоков :keyword:`elif`, а блок :keyword:`else`
--- необязательный. Ключевое слово :keyword:`elif` --- это сокращение для 'else
if', оно полезно, чтобы избежать чрезмерных отступов. Последовательность
:keyword:`if` ... :keyword:`elif` ... :keyword:`elif` ... призвана заменить
``switch`` или ``case`` которые можно встретить в других языках.


.. _tut-for:

Оператор :keyword:`for`
=======================

.. index::
   statement: for

Оператор :keyword:`for` в Python несколько отличается от того, к которому вы
привыкли в C или Pascal. Вместо того, чтобы всегда проходить по арифметической
прогрессии из чисел (как в Pascal), или давать пользователю возможность
определять шаг итерации и условие останова (как в C), оператор :keyword:`for` в
Python проходит по элементам последовательности (список или строка) в том
порядке, в котором они находятся в последовательности. Для примера (шутки не
уместны):

.. One suggestion was to give a real C example here, but that may only serve to
   confuse non-C programmers.

::

   >>> # Измерим несколько строк:
   ... words = ['cat', 'window', 'defenestrate']
   >>> for w in words:
   ...     print(w, len(w))
   ...
   cat 3
   window 6
   defenestrate 12

Если вам нужно изменить последовательность, для которой выполняется цикл
(например чтобы продублировать выбранные элементы), рекомендуется сначала
сделать копию этой последовательности. Обход последовательности не делает копию
неявно. С помощью операции среза делать это особенно удобно::

   >>> for w in words[:]:  # Цикл проходит по копии всего списка.
   ...     if len(w) > 6:
   ...         words.insert(0, w)
   ...
   >>> words
   ['defenestrate', 'cat', 'window', 'defenestrate']


.. _tut-range:

Функция :func:`range`
=====================

Если вам нужно обходить последовательность чисел, то пригодится встроенная
функция :func:`range`. Она создаёт арифметические прогрессии::

    >>> for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4

Заданная конечная точка не является частью последовательности: ``range(10)``
создаёт 10 значений, правильные индексы элементов последовательности длиной 10.
Можно задать диапазон, начиная с другого числа или определить другое приращение
(даже отрицательное; иногда его называют 'шаг')::

    range(5, 10)
       от 5 до 9

    range(0, 10, 3)
       0, 3, 6, 9

    range(-10, -100, -30)
      -10, -40, -70

Для обхода индексов последовательности, вы можете комбинировать :func:`range` и
:func:`len`, как показано далее::

   >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
   >>> for i in range(len(a)):
   ...     print(i, a[i])
   ...
   0 Mary
   1 had
   2 a
   3 little
   4 lamb

В большинстве подобных случаев, однако, удобно использовать функцию
:func:`enumerate`, см. :ref:`tut-loopidioms`.

Странные вещи происходят, если вы хотите просто напечатать диапазон::

   >>> print(range(10))
   range(0, 10)

Во многих случаях объект, возвращённый :func:`range`, ведёт себя как будто бы
это список, но фактически это не так. Это объект, который возвращает
последовательные элементы желаемой последовательности, которую вы обходите, но
в действительности он не делает список, таким образом, сохраняя пространство.

Мы сказали, что такой объект *итерируемый*, т.е. подходящий как цель для
функций и конструкций, которые ожидают что-то от чего они могут получить
последующие элементы пока запас не иссякнет. Мы видели, что оператор
:keyword:`for` --- это такой *итератор*. Функция :func:`list` --- другой, она
создаёт список из итерируемых объектов::


   >>> list(range(5))
   [0, 1, 2, 3, 4]

Позже мы увидим больше функций, которые возвращают итерируемые объекты и
принимают их как аргументы.


.. _tut-break:

Операторы :keyword:`break`, :keyword:`continue` и :keyword:`else` для циклов
============================================================================

Оператор :keyword:`break`, как и в C, прерывает ближайший цикл
:keyword:`for` или :keyword:`while`.


Операторы циклов могут иметь блок ``else``; он выполняется когда цикл
завершается после окончания списка (для :keyword:`for`) или когда условие
становится равным false (для :keyword:`while`), но не когда цикл прерывается
оператором :keyword:`break`. Это демонстрируется в следующем примере цикла ,
который ищет простые числа::

   >>> for n in range(2, 10):
   ...     for x in range(2, n):
   ...         if n % x == 0:
   ...             print(n, 'равно', x, '*', n//x)
   ...             break
   ...     else:
   ...         # цикл проходит до конца не найдя множитель
   ...         print(n, 'это простое число
   ...
   2 это простое число
   3 это простое число
   4 равно 2 * 2
   5 это простое число
   6 равно 2 * 3
   7 это простое число
   8 равно 2 * 4
   9 равно 3 * 3

(Да, это корректный код. Посмотрите внимательнее: блок ``else`` принадлежит
циклу :keyword:`for`, а **не** оператору :keyword:`if`).

Применительно к циклам, блок ``else`` имеет много общего с блоком ``else``
оператора :keyword:`try`, чем с оператором :keyword:`if`: раздел ``else``
оператора :keyword:`try` выполняется, когда не случается исключений, а раздел
``else`` циклов выполняется, когда не встречается ``break``. Более подробно про
оператор :keyword:`try` и исключения см. :ref:`tut-handling`.

Оператор :keyword:`continue` также заимствован из C, продолжающий со следующей
итерации цикла::

    >>> for num in range(2, 10):
    ...     if num % 2 == 0:
    ...         print("Найдено чётное число", num)
    ...         continue
    ...     print("Найдено число", num)
    Найдено чётное число 2
    Найдено число 3
    Найдено чётное число 4
    Найдено число 5
    Найдено чётное число 6
    Найдено число 7
    Найдено чётное число 8
    Найдено число 9

.. _tut-pass:

Оператор :keyword:`pass`
========================

Оператор :keyword:`pass` ничего не делает. Он может использоваться, когда
оператор требуется синтаксически, но программа не требует действий. Например::

   >>> while True:
   ...     pass  # Ожидание прерывания с клавиатуры (Ctrl+C)
   ...

Он обычно используется для создания минимальных классов::

   >>> class MyEmptyClass:
   ...     pass
   ...

Также :keyword:`pass` может использоваться как заглушка для функции или тела условия,
когда вы работаете над новым кодом, позволяя думать на более абстрактном
уровне. :keyword:`pass` молча игнорируется::

   >>> def initlog(*args):
   ...     pass   # Не забудте реализовать это!
   ...

.. _tut-functions:

Определение функций
===================

Мы можем создать функцию, которая пишет последовательность Фибоначчи до
произвольной границы::

   >>> def fib(n):    # вывести ряд Фибоначчи вплоть до n
   ...     """Печатает ряд Фибоначчи вплоть до n."""
   ...     a, b = 0, 1
   ...     while a < n:
   ...         print(a, end=' ')
   ...         a, b = b, a+b
   ...     print()
   ...
   >>> # Теперь вызовем функцию которую мы только что определили:
   ... fib(2000)
   0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

.. index::
   single: documentation strings
   single: docstrings
   single: strings, documentation

Ключевое слово :keyword:`def` начинает *определение* функции. Затем должно идти
имя функции и в скобках список формальных параметров. Операторы, которые
формируют тело функции, начинаются на следующей строке и должны быть выделены
отступом.


Первый оператор тела функции опционально может быть строковым литералом; этот
строковый литерал - строка документации функции или :dfn:`docstring`. Больше
подробностей о docstring вы можете найти в разделе :ref:`tut-docstrings`).
Существуют инструменты, которые используют docstring для автоматического
создания онлайн или печатной документации, или для того, чтобы позволить
пользователю интерактивно перемещаться по коду; это хорошая практика ---
включать docstring в код, который вы пишете, завести такую привычку.

*Выполнение* функции вводит новую таблицу символов, используемую для локальных
переменных функции. Более точно, все переменные, созданные в функции, хранят
значения в локальной таблице символов; в то время как ссылки на переменные
сначала ищутся в локальной таблице символов, затем в локальной таблице символов
обрамляющих функций, затем в глобальной таблице символов, и, наконец, в таблице
встроенных имён. Таким образом, глобальным переменным не могут быть присвоены
значения внутри функции (если они не названы в операторе :keyword:`global`),
хотя на них могут быть ссылки.

Непосредственные параметры (аргументы) функции размещены в локальной таблице
вызываемой функции; таким образом, аргументы передаются *по значению* (где
*значением* всегда является *ссылка* на объект, а не значение объекта). [#]_
Когда одна функция вызывает другую функцию, для этого вызова создаётся новая
локальная таблица символов.

Определение функции включает в себя имя функции в текущей символьной таблице.
Значение имени функции имеет тип, распознаваемый переводчиком как функция,
определяемая пользователем. Этому значению может быть присвоено другое имя,
которое позже также может быть использовано как функция. Это служит основным
механизмом переименования::

   >>> fib
   <function fib at 10042ed0>
   >>> f = fib
   >>> f(100)
   0 1 1 2 3 5 8 13 21 34 55 89

Если вы знакомы с другими языками, то можете возразить, что ``fib`` не функция,
а процедура, поскольку она не возвращает значение. В самом деле, даже функции
не возвращающие значения --- возвращают значение, хотя и довольно скучное. Это
значение называется ``None`` (это зарезервированное слово). Вывод значения
``None`` обычно не производится интерпретатором, если это будет единственное
выводимое значение. Вы можете увидеть его, если действительно хотите, используя
:func:`print`::

   >>> fib(0)
   >>> print(fib(0))
   None

Очень просто написать функцию, которая возвращает список чисел из ряда
Фибоначчи, а не выводит их на экран::

   >>> def fib2(n): # возвращает ряд Фибоначчи вплоть до n
   ...     """Возвращает список, который содержит ряд Фибоначчи вплоть до n"""
   ...     result = []
   ...     a, b = 0, 1
   ...     while a < n:
   ...         result.append(a)    # смотрите ниже
   ...         a, b = b, a+b
   ...     return result
   ...
   >>> f100 = fib2(100)    # вызываем это
   >>> f100                # выводит результат
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

Этот пример, как обычно, демонстрирует некоторые новые особенности языка
Python:

* Оператор :keyword:`return` завершает функцию и возвращает значение.
  :keyword:`return` без аргумента возвращает ``None``. Достижение конца 
  функции также возвращает ``None``.

* Выражение ``result.append(a)`` вызывает *метод* списка по имени 
  ``result``.  Метод это функция, которая 'принадлежит' названному объекту
  ``obj.methodname``, где ``obj`` это некий объект (это может быть выражение), а
  ``methodname`` это имя метода который определяется типом объекта.  Различные
  типы определяют различные методы.  Методы разных типов могут иметь одинаковые
  имена, не вызывая неоднозначности. (Возможно определять ваши собственные типы и
  методы объектов, используя *классы*, см. :ref:`tut-classes`) Метод
  :meth:`append` показанный в этом примере определён для объектов типа list
  (список); он добавляет новый элемент в конец списка.  В этом примере
  эквивалентно ``result = result + [a]``, но более эффективно.


.. _tut-defining:

Подробнее об определении функций
================================

Также вожмонжо объявить функцию с переменным числом параметров. Для этого есть
три способа, которые могут быть скомбинированы.


.. _tut-defaultargs:

Значения по умолчанию для параметров
------------------------------------

Наиболее полезный способ --- это указать значение по умолчанию для одного или
более параметров. Это позволит создать функцию, которая может быть вызвана с
меньшим количеством параметров, чем она объявлена. Например::

   def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
       while True:
           ok = input(prompt)
           if ok in ('y', 'ye', 'yes'):
               return True
           if ok in ('n', 'no', 'nop', 'nope'):
               return False
           retries = retries - 1
           if retries < 0:
               raise OSError('uncooperative user')
           print(complaint)

Эта функция может быть вызвана несколькими способами:

* передачей только  только необходимых параметров:
  ``ask_ok('Do you really want to quit?')``
* передачей одного из необязательных параметров:
  ``ask_ok('OK to overwrite the file?', 2)``
* или передачей всех параметров:
  ``ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')``

Этот пример знакомит нас с ключевым словом :keyword:`in`. Оно проверяет
содержит ли последовательность определённое значение.

Значения по умолчанию вычисляются в месте объявления функции в области
видимости *объявления*, таким образом ::

   i = 5

   def f(arg=i):
       print(arg)

   i = 6
   f()

Выведет ``5``.

**Важное предупреждение:** значение по умолчанию вычисляется лишь раз. Это имеет
значение когда значением по умолчанию является изменяемый объект, например
список, словарь, или экземпляры большинства классов. Например, следующая
функция собирает параметры переданные ей в последовательные вызовы::

   def f(a, L=[]):
       L.append(a)
       return L

   print(f(1))
   print(f(2))
   print(f(3))

Будет выведено на печать ::

   [1]
   [1, 2]
   [1, 2, 3]

Если же вы не хотите, чтобы значение по умолчанию было одинаковым для
последовательных вызовов, то вы можете переписать функцию следующим образом::

   def f(a, L=None):
       if L is None:
           L = []
       L.append(a)
       return L


.. _tut-keywordargs:

Именованные агрументы
---------------------

Функции могут также вызываться с использованием :term:`keyword arguments
<keyword argument>` (именованных аргументов), в форме ``kwarg=value``. Например,
следующая функция::

   def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
       print("-- This parrot wouldn't", action, end=' ')
       print("if you put", voltage, "volts through it.")
       print("-- Lovely plumage, the", type)
       print("-- It's", state, "!")

принимает один обязательный аргумент (``voltage``) и три необязательных
аргумента (``state``, ``action`` и ``type``). Эта функция может быть вызвана
любым из следующих способов::

   parrot(1000)                                          # 1 позиционный аргумент
   parrot(voltage=1000)                                  # 1 именованный аргумент
   parrot(voltage=1000000, action='VOOOOOM')             # 2 именованных аргумента
   parrot(action='VOOOOOM', voltage=1000000)             # 2 именованных агрумента
   parrot('a million', 'bereft of life', 'jump')         # 3 позиционных аргумента
   parrot('a thousand', state='pushing up the daisies')  # 1 позиционный, и 1 именованный

но все следующие вызовы будут неправильные::

   parrot()                     # необходимый аргумент пропущен
   parrot(voltage=5.0, 'dead')  # неименованный аргумент после именованного
   parrot(110, voltage=220)     # повторяющееся значение для одинакового аргумента
   parrot(actor='John Cleese')  # неизвесный именованный аргумент

При вызове функции именованные аргументы должны идти после позиционных
аргументов. Все переданные именованные аргументы должны соответствовать одному
из аргументов, принимаемых функцией (т.е. ``actor`` --- неправильный аргумент
для функции ``parrot``), но их порядок не важен. Это также относится к
обязательным аргументам (т.е. ``parrot(voltage=1000)`` это также правильно).
Аргументы не могут принимать больше одного значения. Этот пример не сработает
из-за этого ограничения::

   >>> def function(a):
   ...     pass
   ...
   >>> function(0, a=0)
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   TypeError: function() got multiple values for keyword argument 'a'

Когда окончательный формальный параметр вида  ``**имя`` присутствует, он
получает словарь (см. :ref:`typesmapping`), содержащий все именованные аргументы
кроме тех, которые соответствуют формальным параметрам. (``*имя`` должно стоять
до ``**имя``). Например, если мы определим функцию следующим образом::

   def cheeseshop(kind, *arguments, **keywords):
       print("-- Do you have any", kind, "?")
       print("-- I'm sorry, we're all out of", kind)
       for arg in arguments:
           print(arg)
       print("-" * 40)
       keys = sorted(keywords.keys())
       for kw in keys:
           print(kw, ":", keywords[kw])

Она может быть вызвана примерно так::

   cheeseshop("Limburger", "It's very runny, sir.",
              "It's really very, VERY runny, sir.",
              shopkeeper="Michael Palin",
              client="John Cleese",
              sketch="Cheese Shop Sketch")

и конечно она выведет::

   -- Do you have any Limburger ?
   -- I'm sorry, we're all out of Limburger
   It's very runny, sir.
   It's really very, VERY runny, sir.
   ----------------------------------------
   client : John Cleese
   shopkeeper : Michael Palin
   sketch : Cheese Shop Sketch

Обратите внимание, что список именованных аргументов создаётся путём сортировки
результата словарного метода ``keys()`` перед тем как вывести его содержимое;
если этого не сделать, то порядок в котором выводятся аргументы не определён.

.. _tut-arbitraryargs:

Списки произвольных аргументов
------------------------------

.. index::
  statement: *

Наконец, наименее часто используемая возможность это указать, что функция может
быть вызвана с произвольным колличеством аргументов.  Эти аргументы будут
"обёрнуты" в кортеж (см. :ref:`tut-tuples`).  Перед переменным количеством
аргументов, может стоять ноль или более обычных аргументов. ::

   def write_multiple_items(file, separator, *args):
       file.write(separator.join(args))

Как правило, эти параметры (называемые ``variadic`` параметры), будут
последними в списке формальных параметров, потому что они "забирают" все
оставшиеся входные аргументы, которые передаются в функцию. Назад Любые
формальные параметры, которые следуют после параметра ``*args`` являются
"только-именованными" параметрами, это означает, что они могут быть
использованы только в качестве именованных, а не позиционных параметров. ::

   >>> def concat(*args, sep="/"):
   ...    return sep.join(args)
   ...
   >>> concat("earth", "mars", "venus")
   'earth/mars/venus'
   >>> concat("earth", "mars", "venus", sep=".")
   'earth.mars.venus'

.. _tut-unpacking-arguments:

Распаковка списка аргументов
----------------------------

Обратная ситуация возникает, когда аргументы уже в списке или кортеже, но
должны быть распакованы для вызова функции, требующей отдельных позиционных
аргументов.  Например, встроенная функция :func:`range` ожидает отдельные
аргументы *начала* и *конца*.  Если они недоступны отдельно, напишите вызов
функции с оператором ``*`` чтобы распаковать аргументы из списка или кортежа::

   >>> list(range(3, 6))            # обычный вызов с отдельными аргументами
   [3, 4, 5]
   >>> args = [3, 6]
   >>> list(range(*args))           # вызов с аргументами распакованными из списка
   [3, 4, 5]

.. index::
  statement: **

Таким же образом, словари могут содержать именованные параметры при помощи
оператора ``**``::

   >>> def parrot(voltage, state='a stiff', action='voom'):
   ...     print("-- This parrot wouldn't", action, end=' ')
   ...     print("if you put", voltage, "volts through it.", end=' ')
   ...     print("E's", state, "!")
   ...
   >>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
   >>> parrot(**d)
   -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !


.. _tut-lambda:

Лямбда выражения --- Небольшие анонимные функции могут быть созданы с помощью
ключевого слова :keyword:`lambda`.  Эта функция возвращает сумму двух своих
аргументов: ``lambda a, b: a+b``.  Лямбда-функции могут использоваться в местах
где требуются объекты-функции.  Они синтаксически ограничены одним выражением.
Семантически, они просто синтаксический сахар для определения обычной функции.
Вроде вложенных функций, лямбда-функции могут ссылаться на переменные
содержащей их зоны видимости::

   >>> def make_incrementor(n):
   ...     return lambda x: x + n
   ...
   >>> f = make_incrementor(42)
   >>> f(0)
   42
   >>> f(1)
   43

Пример выше использует лямбда-выражение чтобы вернуть функцию.  Другой способ
применения --- передать маленькую функцию в качестве аргумента::

   >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
   >>> pairs.sort(key=lambda pair: pair[1])
   >>> pairs
   [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]


.. _tut-docstrings:

Строки документации
-------------------

.. index::
   single: docstrings
   single: documentation strings
   single: strings, documentation

Вот некоторые соглашения о содержании и форматирования строк документации.

Первая строка всегда должна быть краткой, краткое сводка о назначении объекта.
Для краткости, она не должна явно указывать имя или тип объекта, поскольку они
доступны другими способами (за исключением, если имя функции - глагол,
описывающий действие функции).  Эта строка должна начинаться с заглавной буквы
и заканчиваться точкой.


Если есть ещё несколько строк в документации, вторая строка должна быть пустой,
визуально отделяя сводку от остального описания.  Следующие строки должны быть
одним или несколькими пунктами, описывающими соглашения о вызовах объекта, его
побочные эффекты и т.д.

Парсер Питона не удаляет отступы из многострочных комментариев в Питоне, так
что программы которые обрабатывают документацию должны удалять отступы, если
нужно.  Это делается согласно следующему соглашению. Первая не пустая стока
*после* первой строки текста определяет отступ для всего текста документации.
(Мы не можем использовать первую строку, поскольку она, как правило, рядом с
открывающей кавычкой так что её отступ не очевидно в строковом литерале).
Пробелы "эквивалентные" этому отступу затем удаляются из начала всех строк в
тексте.  Линий, с меньшим отступом не должно быть, но если они есть, все их
начальные пробелы должны быть удалены.  Эквивалентность пробелов, должны быть
проверена после замены табуляций (до 8-ми пробелов, обычно).

Вот пример многострочного текста документации::

   >>> def my_function():
   ...     """Ничего не делает, но содержит документацию.
   ...
   ...     Нет, правда, она совсем ничего не делает.
   ...     """
   ...     pass
   ...
   >>> print(my_function.__doc__)
   Ничего не делает, но содержит документацию.

       Нет, правда, она совсем ничего не делает.


.. _tut-annotations:

Аннотации функций
-----------------

.. sectionauthor:: Zachary Ware <zachary.ware@gmail.com>
.. index::
   pair: function; annotations
   single: -> (return annotation assignment)

:ref:`Function annotations <function>` совершенно необязательные, произвольные
метаданные о пользовательских функциях.  Ни сам Python, ни стандартная
библиотека, не используют аннотации функций в любой форме; Этот раздел просто
показывает синтаксис.  Сторонние проекты могут свободно использовать аннотации
функций в качестве документации, проверки типов и других целей.

Аннотации хранятся в атрибуте функции :attr:`__annotations__` в виде словаря и
не имеют никакого влияния на какую-либо другую часть функции.  Аннотации
параметров определяются двоеточием после имени параметра, за которым следует
выражение которое преобразуется в значение аннотации.  Аннотации return
определяются литералом `->`, за ни следует выражение, между списком параметров
и двоеточием, обозначающим конец :keyword:`def` выражения. Следующий пример
содержит позиционный аргумент и именованный аргумент, а возвращаемое значение
аннотировано бессмыслицей::

   >>> def f(ham: 42, eggs: int = 'spam') -> "Nothing to see here":
   ...     print("Annotations:", f.__annotations__)
   ...     print("Arguments:", ham, eggs)
   ...
   >>> f('wonderful')
   Annotations: {'eggs': <class 'int'>, 'return': 'Nothing to see here', 'ham': 42}
   Arguments: wonderful spam


.. _tut-codingstyle:

Интермеццо: Стиль кодирования
=============================

.. sectionauthor:: Georg Brandl <georg@python.org>
.. index:: pair: coding; style

Теперь, когда вы собираетесь писать более длинные, более сложные куски Python,
пришло время, чтобы поговорить о *стиле кодирования*.  На большинстве языков
можно писать (имеется в виду *форматирование*) в различных стилях; некоторые из
них легче читать, чем другие.  Облегчить другим чтение вашего кода, это всегда
хорошая идея, и принятие хорошего стиля кодирования чрезвычайно помогает в
этом.


Для Python, :pep:`8` появился как руководство по стилю, которого придерживается
большинство проектов; это способствует очень читаемому и радующему глаз стилю
кодирования.  Каждый питон-разработчик должен прочитать его в какой-то момент;
вот наиболее важные моменты, выписанные для вас:

* Используйте 4-пробела для отступов, не табуляции.

  4 пробела, это хороший компромисс между малым отступом (обеспечивает большую
  глубину вложений) и большим отступом (легче читать).  Табуляция вносит
  путаницу и лучше её не использовать.

* Переносите строки длиннее 79 символов.

  Это помогает пользователям с небольшими дисплеями и позволяет иметь несколько
  файлов кода бок-о-бок на больших экранах.

* Используйте пустые строки для отделения функций и классов, и крупных блоков
  кода внутри функции.

* Когда это возможно, пишите комментарии с новой строки.

* Используйте docstrings.

* Используйте пробелы вокруг операторов и после запятых, но не непосредственно
  в скобках в конструкциях вида: ``a = f(1, 2) + g(3, 4)``.

* Называйте классы и функции последовательно; согласно конвенции используйте
  ``CamelCase`` для классов и называйте методы и функции
  ``в_нижнем_регистре_с_подчёркиваниями_вместо_пробелов``.  Всегда используйте
  ``self`` в качестве имени первого аргумента метода (см. Первое знакомство с
  классами и методами).  (см. :ref:`tut-firstclasses` для получения подробной
  информации о классах и методах).

* Не используйте причудливые кодировки, если ваш код предназначен для
  использования в международной среде.  Стандартная для Python, UTF-8, или даже
  простой ASCII в любых ситуациях подходят лучше всего.

* Кроме того, не используйте символы, отличные от ASCII в идентификаторах, если
  есть малейший шанс того, что люди, говорящие на разных языках будут читать
  или поддерживать ваш код.


.. rubric:: Footnotes

.. [#] На самом деле, *вызов по ссылке на объект* было бы лучшим описанием,
   поскольку, если передаётся изменяемый объект, вызывающий будет видеть любые
   изменения которые вызванный сделает (элементы вставленные в список).
