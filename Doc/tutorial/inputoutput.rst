.. _tut-io:

************
Ввод и вывод
************

Есть несколько способов продемонстрировать вывод программы; данные могут быть
выведены в читабельном виде или записаны в файл для последующего использования.
Часть возможностей будет обсуждена в этой главе.


.. _tut-formatting:

Fancier Output Formatting
=========================

На данный момент мы столкнулись с двумя способами вывода значений: выражения с
операторами (*expression statments*) и функцией :func:`print`.  Третий способ
-- использование метода :meth:`write` объектов файлов; на файл стандартного
вывода можно сослаться как ``sys.stdout``. Более подробную информацию смотрите
в Справочнике Библиотеки.

Часто возникает желание иметь больший контроль над форматирование вывода, чем
обычная печать значений разделённых пробелами.  Имеется два способа сделать
форматирование вывода; первый способ сделать всю обработку самому; используя
нарезку строк и операции конкатенации вы можете создать любой макет, который
можете представить. Строковый тип имеет способ, который позволяет использовать
операции для заполнения строк в столбцах заданной ширины.  Второй способ --
использование метода :meth:`str.format`.

Модуль :mod:`string` содержит класс :class:`~string.Template`, который
предоставляет другой способ подстановки значений в строки.

Конечно, остаётся один вопрос: как конвертировать значения в строку? К счастью,
Python имеет способ конвертации любого значения в строку: подставляет в функцию
:func:`repr` или :func:`str`.

Функция :func:`str` предназначена для представления значений в удобно читаемом
виде, в то время как :func:`repr` предназначена для представления, которое
может быть прочитано интерпретатором (или вызовет синтаксическую ошибку
:exc:`SyntaxError`, если нет эквивалентного синтаксиса) Для объектов, которые
не имеют конкретного человекочитаемого представления, :func:`str` возвратит то
же значение, что и :func:`repr`.  Многие значения, такие как цифры или
структуры, вроде списков и словарей, имеют одинаковое представление в обеих
функциях. Строки, в частности, имеют два разных представления.

Несколько примеров::

   >>> s = 'Hello, world.'
   >>> str(s)
   'Hello, world.'
   >>> repr(s)
   "'Hello, world.'"
   >>> str(1/7)
   '0.14285714285714285'
   >>> x = 10 * 3.25
   >>> y = 200 * 200
   >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
   >>> print(s)
   The value of x is 32.5, and y is 40000...
   >>> # repr()  cтроки добавляет ей кавычки и обратные слеши:
   ... hello = 'hello, world\n'
   >>> hellos = repr(hello)
   >>> print(hellos)
   'hello, world\n'
   >>> # Аргументом repr() может стать любой объект Питона:
   ... repr((x, y, ('spam', 'eggs')))
   "(32.5, 40000, ('spam', 'eggs'))"

Вот два способа вывести таблицу квадратов и кубов::

   >>> for x in range(1, 11):
   ...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
   ...     # Обратите внимание на использование 'end' в предыдущей строке
   ...     print(repr(x*x*x).rjust(4))
   ...
    1   1    1
    2   4    8
    3   9   27
    4  16   64
    5  25  125
    6  36  216
    7  49  343
    8  64  512
    9  81  729
   10 100 1000

   >>> for x in range(1, 11):
   ...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
   ...
    1   1    1
    2   4    8
    3   9   27
    4  16   64
    5  25  125
    6  36  216
    7  49  343
    8  64  512
    9  81  729
   10 100 1000

(Обратите внимание, в первом примере единичные пробелы между столбцов добавлены
за счёт работы функции :func:`print`: она всегда добавляет пробелы между своими
аргументами) 

Этот пример демонстрирует метод строковых объектов :meth:`str.rjust`, который
выравнивает строку по правому краю в поле переданной ширины, отступая пробелами
слева.  Есть также похожие методы :meth:`str.ljust` и :meth:`str.center`.  Эти
методы не выводят ничего, они просто возвращают новую строку. Если входящая
строка слишком длинна, они не укорачивают её, а оставляют её неизменной; это
будет портить расположение колонки, но что обычно лучше альтернативы, которая
бы лгала о длительности. (Если вы действительно хотите усечения, вы можете
всегда добавить команду нарезки, как в `x.ljust(n)[:n]``).

Есть другой метод :meth:`str.zfill`, который заполняет числовые строки нулями
слева.  Он распознает знаки плюс и минус::

   >>> '12'.zfill(5)
   '00012'
   >>> '-3.14'.zfill(7)
   '-003.14'
   >>> '3.14159265359'.zfill(5)
   '3.14159265359'

Основной способ использования метода :meth:`str.format` выглядит так::

   >>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
   We are the knights who say "Ni!"

Скобки и символы которые они окружают (они называются полями форматирования)
заменяются на объекты переданные в метод :meth:`str.format`. Число в скобках может
быть использовано для указания положения объекта, переданного в метод
:meth:`str.format`. ::

   >>> print('{0} and {1}'.format('spam', 'eggs'))
   spam and eggs
   >>> print('{1} and {0}'.format('spam', 'eggs'))
   eggs and spam

Если в методе :meth:`str.format` используются именованные аргументы, то на их
значения можно ссылаться используя имя аргумента. ::

   >>> print('This {food} is {adjective}.'.format(
   ...       food='spam', adjective='absolutely horrible'))
   This spam is absolutely horrible.

Позиционные и именованные аргументы можно произвольно совмещать::

   >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
                                                          other='Georg'))
   The story of Bill, Manfred, and Georg.

``'!a'`` (применить :func:`ascii`), ``'!s'`` (применить :func:`str`) и ``'!r'``
(применить :func:`repr`) могут быть использованы чтобы преобразовать значение
перед форматированием::

   >>> import math
   >>> print('The value of PI is approximately {}.'.format(math.pi))
   The value of PI is approximately 3.14159265359.
   >>> print('The value of PI is approximately {!r}.'.format(math.pi))
   The value of PI is approximately 3.141592653589793.

Необязательное ``':'`` и спецификатор формата могут следовать за именем поля.
Это позволяет лучше контролировать, как значение будет отформатировано.
Следующий пример округляет Pi до трёх знаков после запятой. ::

   >>> import math
   >>> print('The value of PI is approximately {0:.3f}.'.format(math.pi))
   The value of PI is approximately 3.142.

Передача целого после ``':'`` приведёт к тому, чтобы поле было минимум это
количество символов в ширину. Это позволяет делать таблицы ровными. ::

   >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
   >>> for name, phone in table.items():
   ...     print('{0:10} ==> {1:10d}'.format(name, phone))
   ...
   Jack       ==>       4098
   Dcab       ==>       7678
   Sjoerd     ==>       4127

Если у вас есть действительно длинная строка формата, которую вы не хотите
делить, было бы неплохо, если бы вы могли ссылаться на переменные с строке
формата по имени, а не по позиции. Этого можно достигнуть, просто передав
словарь и используя квадратные скобки ``'[]'`` для доступа к ключам ::

   >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
   >>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
   ...       'Dcab: {0[Dcab]:d}'.format(table))
   Jack: 4098; Sjoerd: 4127; Dcab: 8637678

Это также может быть сделано путём передачи таблицы, в качестве именованных
аргументом с '**' нотацией. ::

   >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
   >>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
   Jack: 4098; Sjoerd: 4127; Dcab: 8637678

Это особенно полезно в сочетании со встроенной функцией :func:`vars`, которая
возвращает словарь, содержащий все локальные переменные.

Для полного обзора форматирования строк с помощью :meth:`str.format`, см.
:ref:`formatstrings`.


Форматирования строк в старом стиле
-----------------------------------

Оператор ``%`` так же может использоваться для форматирования строк. Он
интерпретирует левый аргумент похожим на :c:func:`sprintf` способом применяя
строку формата к правому аргументу, и возвращает строку в результате этой
операции форматирования. Например::

   >>> import math
   >>> print('The value of PI is approximately %5.3f.' % math.pi)
   The value of PI is approximately 3.142.

За дополнительной информацией обратитесь к разделу
:ref:`old-string-formatting`.


.. _tut-files:

Чтение и запись файлов
======================

.. index::
   builtin: open
   object: file

:func:`open` возвращает :term:`file object`, и чаще всего используется с двумя
аргументами: ``open(filename, mode)``.

::

   >>> f = open('workfile', 'w')

.. XXX str(f) is <io.TextIOWrapper object at 0x82e8dc4>

   >>> print(f)
   <open file 'workfile', mode 'w' at 80a0960>

Первый аргумент -- строка содержащая имя файла.  Второй, другая строка содержащая
символы описывающие способ при помощи которого будет использоваться файл.
*mode* может быть ``'r'`` когда нужно только прочитать файл, ``'w'`` только
для записи (существующий файл с тем же именем будет стёрт), и ``'a'`` открывает
файл для дописывания; любые данные записанные в файл, автоматически добавляются
в конец.  ``r+`` открывает файл для записи и чтения. Аргумент *mode*
необязательный; будет использован ``'r'`` если ничего не указано.

Обычно файлы открываются в :dfn:`text mode`, это означает, что вы
читаете и пишете строки в файл, которые закодированы в специальной кодировке
(по умолчанию используется UTF-8).  ``'b'`` добавленное в режим открывает файл
в :dfn:`binary mode`: теперь данные читаются и записываются в
виде байтов.  Этот режим следует использовать для всех файлов не содержащих
текст.

В текстовом режиме, по умолчанию при чтении специфичные для платформы концы
строк (``\n`` на Unix, ``\r\n`` на Windows), конвертируются в простое ``\n``.
При записи в текстовом режиме, по умолчанию все ``\n`` конвертируются в
специфичные для платформы концы строк.  Эта закулисная модификация данных
файла, хороша для текстовых файлов, но повредит двоичные данные, такие как в
:file:`JPEG` или :file:`EXE` файлах.  Будьте внимательны и используйте двоичный
режим когда читаете и пишете такие файлы.


.. _tut-filemethods:

Методы объекта файл
-------------------

В остальных примерах этого раздела будем предполагать, что файловый объект, под
названием ``f``, уже создан.  Чтобы прочитать содержимое файла, вызовите
``f.read(размер)``, который читает некое количество данных и возвращает эти
данные как строку или байтовый объект.  *размер* является необязательным
числовым аргументом. Когда *размер* опущен или отрицателен, всё содержимое
файла будет прочитано и возвращено; это ваша проблема, если файл вдвое больше
объёма памяти компьютера. В противном случае, максимально возможная часть от
указанного *размера* байтов будет прочитана и возвращена.  Если достигнут конец
файла, ``f.read()`` вернёт пустую строку (``''``). ::

   >>> f.read()
   'This is the entire file.\n'
   >>> f.read()
   ''

``f.readline()`` читает одну строку из файла; символ новой строки (``\n``)
остаётся в конце строки и он отсутствует в последней строке только в случае
если файл не заканчивается новой строкой.  Это делает возвращаемое значение
однозначным; если ``f.readline()`` возвращает пустую строку, значит достигнут
конец файла, в то время как пустая строка представлена в виде ``\n``, строкой
содержащей только символ новой строки. ::

   >>> f.readline()
   'This is the first line of the file.\n'
   >>> f.readline()
   'Second line of the file\n'
   >>> f.readline()
   ''

Для чтения строк из файла, вы можете пройти циклом по объекту файл.  Это
эффективно по потреблению памяти, быстро и ведёт к простому коду::

   >>> for line in f:
   ...     print(line, end='')
   ...
   This is the first line of the file.
   Second line of the file

Если вы хотите прочитать все строки из файла в список, вы можете использовать
``list(f)`` или ``f.readlines()``.

``f.write(string)`` записывает содержимое *string* в файл, возвращая
количество записанных символов. ::

   >>> f.write('This is a test\n')
   15

Чтобы записать что-то отличающееся от строки, в начале вам необходимо
преобразовать это в строку. ::

   >>> value = ('the answer', 42)
   >>> s = str(value)
   >>> f.write(s)
   18

``f.tell()`` возвращает целое которое указывает на текущую позицию в файле,
число указывает на количество байтов от начала файла в двоичном режиме и
непрозрачное число когда в текстовом режиме.

Чтобы изменить позицию в файле, используйте ``f.seek(сдвиг, откуда)``.  Позиция
вычисляется добавлением *сдвига* от указанной точки; указанная точка берётся из
аргумента *откуда*.  Значение аргумента *откуда* равное 0, означает от начала
файла, 1 -- от текущей позиции в файле, 2 -- с конца файла, в качестве точки
отсчёта.  *откуда* может быть опущен и по умолчанию равен 0, используя начало
файла как точку отсчёта. ::

   >>> f = open('workfile', 'rb+')
   >>> f.write(b'0123456789abcdef')
   16
   >>> f.seek(5)     # Перейти на шестой байт в файле
   5
   >>> f.read(1)
   b'5'
   >>> f.seek(-3, 2) # Перейти на третий байт с конца
   13
   >>> f.read(1)
   b'd'

В текстовых файлах (тех, что открыты без ``b`` в строке режима), разрешён
только поиск относительно начала файла (исключение только поиск в этом самом
файле при помощи ``seek(0, 2)``) и только допустимые значения *сдвига* те, что
возвращает ``f.tell()``, или ноль. Все другие значения *сдвига* приводят к
неопределённому поведению.


Когда вы закончили операции с файлом, вызовите ``f.close()`` чтобы закрыть его
и высвободить все ресурсы задействованные при открытии файла.  После вызова
``f.close()``, попытка использовать объект файла приведёт к неудаче. ::

   >>> f.close()
   >>> f.read()
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   ValueError: I/O operation on closed file

Хорошей практикой является использование оператора keyword:`with` при работе с
объектами файлов.  Вы получаете преимущество в том, что файл будет корректно
закрыт по окончании его использования, даже если в процессе произойдёт
исключительная ситуация.  К тому же, это намного короче чем писать
эквивалентные :keyword:`try`\ -\ :keyword:`finally` блоки::

    >>> with open('workfile', 'r') as f:
    ...     read_data = f.read()
    >>> f.closed
    True

Объекты файлы имеют дополнительные методы, такие как :meth:`~file.isatty` и
:meth:`~file.truncate` которые используются менее часто; обратитесь к
Справочнику Библиотеки за полным гидом по объектам файлов.


.. _tut-json:

Сохранение структурированных данных при помощи :mod:`json`
----------------------------------------------------------

.. index:: module: json

Строки могут быть легко записаны и прочитаны из файла.  Числа требуют чуть
больше усилий, т.к. метод :meth:`read` возвращает только строки, которые должны
быть переданы в функцию вроде :func:`int`, которая принимает строку в виде
``'123'`` и возвращает её числовое значение 123.  Когда вы хотите сохранить
более сложные типы данных вроде вложенных списков или словарей, разбор и
сериализация в ручную становится сложной задачей.

Вместо того чтобы заставлять пользователей постоянно писать и отлаживать код
который сохраняет сложные типы данных в файлы, Python позволяет вам
использовать популярный формат обмена данными называемый `JSON (JavaScript
Object Notation) <http://json.org>`_.  Стандартный модуль называемый
:mod:`json` может преобразовывать иерархии данных Питона в строковые
представления; этот процесс называется :dfn:`serializing`.  Восстановление
данных из строкового представления называется :dfn:`deserializing`.  Между
сериализацией и десереализацией, строка представляющая объект может быть
сохранена в файл или данные, или послана по сети на удалённую машину.

.. note::
   Формат JSON широко применяется в современных приложениях для обмена данными.
   Многие программисты уже знакомы с ним, что делает его хорошим выбором для
   взаимодействия.

Если у вас есть объект ``x``, вы можете увидеть его JSON-представление с
помощью простой строки кода::

   >>> json.dumps([1, 'simple', 'list'])
   '[1, "simple", "list"]'

Другой вариант функции :func:`~json.dumps`, называется :func:`~json.dump`,
сериализует объект в :term:`text file`.  Так что если ``f`` это объект
:term:`text file` открытый для записи, мы можем сделать так::

   json.dump(x, f)

Чтобы раскодировать объект обратно, если ``f`` объект :term:`text file`
открытый для чтения::

   x = json.load(f)

Этот простой приём сериализации может быть задействован для списков и словарей,
но сериализация классов в JSON требует немного больше усилий.  Справка по
модулю :mod:`json` содержит пояснения по этой теме.

.. seealso::

   :mod:`pickle` - модуль pickle

   В отличии от :ref:`JSON <tut-json>`, *pickle* это протокол, который
   допускает сериализацию произвольных сложных объектов Питона.  Так как он
   специфичен для Питона, то не может использоваться для сообщения между
   приложениями написанными на других языках.  К тому же это небезопасно по
   умолчанию: десериализация данных pickle приходящих из непроверенного
   источника может выполнить произвольный код, если эти данные были
   подготовлены умелым атакующим.

